{"pageProps":{"postData":{"id":"tips_and_tricks_for_the_python_interpreter","contentHtml":"<p>I have seen a lot of people switch over to using ipython, bpython, etc\nto get auto-complete support without realizing that the standard\ninterpreter does have this functionality.</p>\n<p>To enable auto-complete support in the python interpreter you need to\ncreate a python startup file that enables readline support. A python\nstartup file is just a bunch of python code that gets executed at\nstartup of the interpreter. To do this you just setup PYTHONSTARTUP in\nyour ~/.bashrc and then create a ~/.pythonrc.py file:</p>\n<pre><code><span>#.bashrc</span>\nPYTHONSTARTUP=~/.pythonrc.py\nexport PYTHONSTARTUP\n\n<span>#.pythonrc.py</span>\n<span>try</span>:\n    <span>import</span> readline\n<span>except</span> ImportError:\n    <span>print</span>(<span>\"Module readline not available.\"</span>)\n<span>else</span>:\n    <span>import</span> rlcompleter\n    readline.parse_and_bind(<span>\"tab: complete\"</span>)</code></pre>\n<p>Now when you are in python you have tab completion on importing, calling\nmethods on a module, etc.</p>\n<pre><code><span>>>> </span><span>import</span> o\n<span>object</span>(  <span>oct</span>(     <span>open</span>(    <span>or</span>       <span>ord</span>(     os</code></pre>\n<p>I always end up using the pretty print module for viewing long lists and\nstrings in the interpreter so I prefer to just use it by default:</p>\n<pre><code><span># Enable Pretty Printing for stdout</span>\n<span>import</span> pprint\n<span>def</span> <span>my_displayhook</span>(<span>value</span>):\n    <span>if</span> value <span>is</span> <span>not</span> <span>None</span>:\n        <span>try</span>:\n            <span>import</span> __builtin__\n            __builtin__._ = value\n        <span>except</span> ImportError:\n            __builtins__._ = value\n\n        pprint.pprint(value)\n\nsys.displayhook = my_displayhook</code></pre>\n<p>It is also very useful to be able to load up your favorite editor to\nedit lines of code from the interpreter, you can do this by adding the\nfollowing into your ~/.pythonrc.py:</p>\n<pre><code><span>import</span> os\n<span>import</span> sys\n<span>from</span> code <span>import</span> InteractiveConsole\n<span>from</span> tempfile <span>import</span> mkstemp\n\nEDITOR = os.environ.get(<span>'EDITOR'</span>, <span>'vi'</span>)\nEDIT_CMD = <span>'\\e'</span>\n\n<span>class</span> <span>EditableBufferInteractiveConsole</span>(<span>InteractiveConsole</span>):\n    <span>def</span> <span>__init__</span>(<span>self, *args, **kwargs</span>):\n        self.last_buffer = [] <span># This holds the last executed statement</span>\n        InteractiveConsole.__init__(self, *args, **kwargs)\n\n    <span>def</span> <span>runsource</span>(<span>self, source, *args</span>):\n        self.last_buffer = [ source.encode(<span>'latin-1'</span>) ]\n        <span>return</span> InteractiveConsole.runsource(self, source, *args)\n\n    <span>def</span> <span>raw_input</span>(<span>self, *args</span>):\n        line = InteractiveConsole.raw_input(self, *args)\n        <span>if</span> line == EDIT_CMD:\n            fd, tmpfl = mkstemp(<span>'.py'</span>)\n            os.write(fd, <span>b'\\n'</span>.join(self.last_buffer))\n            os.close(fd)\n            os.system(<span>'%s %s'</span> % (EDITOR, tmpfl))\n            line = <span>open</span>(tmpfl).read()\n            os.unlink(tmpfl)\n            tmpfl = <span>''</span>\n            lines = line.split( <span>'\\n'</span> )\n            <span>for</span> i <span>in</span> <span>range</span>(<span>len</span>(lines) - <span>1</span>): self.push( lines[i] )\n            line = lines[-<span>1</span>]\n        <span>return</span> line\n\nc = EditableBufferInteractiveConsole(<span>locals</span>=<span>locals</span>())\nc.interact(banner=<span>''</span>)\n\n<span># Exit the Python shell on exiting the InteractiveConsole</span>\nsys.exit()</code></pre>\n<p>For Django developers when you load up the ./manage.py shell it is nice\nto have access to all your models and settings for testing:</p>\n<pre><code><span># If we're working with a Django project, set up the environment</span>\n<span>if</span> <span>'DJANGO_SETTINGS_MODULE'</span> <span>in</span> os.environ:\n    <span>from</span> django.db.models.loading <span>import</span> get_models\n    <span>from</span> django.test.client <span>import</span> Client\n    <span>from</span> django.test.utils <span>import</span> setup_test_environment, teardown_test_environment\n    <span>from</span> django.conf <span>import</span> settings <span>as</span> S\n\n    <span>class</span> <span>DjangoModels</span>(<span>object</span>):\n        <span>\"\"\"Loop through all the models in INSTALLED_APPS and import them.\"\"\"</span>\n        <span>def</span> <span>__init__</span>(<span>self</span>):\n            <span>for</span> m <span>in</span> get_models():\n                <span>setattr</span>(self, m.__name__, m)\n\n    A = DjangoModels()\n    C = Client()</code></pre>\n<p>After these tweaks the python interpreter is a lot more powerful and you\nreally lose the need for the more interactive shells like ipython and\nbpython. All of these settings work in both python2 and python3.</p>\n<p>If you want to see my complete ~/.pythonrc.py you can get it on\n<a href=\"https://github.com/sontek/dotfiles/blob/master/_pythonrc.py\">github</a></p>\n","category":"python\n","date":"2010-12-27T20:00:00-04:00","tags":"python\n","title":"Tips and Tricks for the Python Interpreter"}},"__N_SSG":true}