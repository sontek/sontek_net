{"pageProps":{"postData":{"id":["old","writing_tests_for_pyramid_and_sqlalchemy"],"path":"old/writing_tests_for_pyramid_and_sqlalchemy","contentHtml":"<p>TL;DR: Putting it all together, the full code can be found here:\n<a href=\"https://gist.github.com/1420255\">https://gist.github.com/1420255</a></p>\n<h1>Intro</h1>\n<p>Pyramid's documentation doesn't cover the preferred way to test with\nSQLAlchemy, because Pyramid tries to stay out of your way and allow you\nto make your own decisions. However, I feel i'ts necessary to document\nwhat I think is the best way to test.</p>\n<p>When I first started writing tests with SQLAlchemy I found plenty of\nexamples of how to to get started by doing something like this:</p>\n<pre><code><span>from</span> db <span>import</span> session <span># probably a contextbound sessionmaker</span>\n<span>from</span> db <span>import</span> model\n\n<span>from</span> sqlalchemy <span>import</span> create_engine\n\n<span>def</span> <span>setup</span>():\n    engine = create_engine(<span>'sqlite:///test.db'</span>)\n    session.configure(bind=engine)\n    model.metadata.create_all(engine)\n\n<span>def</span> <span>teardown</span>():\n    model.metadata.drop_all(engine)\n\n<span>def</span> <span>test_something</span>():\n    <span>pass</span></code></pre>\n<p>I have seen this done so many times, but I feel there is so much wrong\nwith it! So let's establish some base rules when testing:</p>\n<blockquote>\n<ul>\n<li>Always test your system like it would be used in production.\nSQLite does not enforce the same rules or have the same features\nas Postgres or MySQL and will allow tests to pass that would\notherwise fail in production.</li>\n<li>Tests should be fast! You should be writing tests for all your\ncode. This is the main reason people do test against SQLite, but\nwe can't violate rule number one. We have to make sure tests\nagainst Postgres are fast, so we shouldn't be tearing down and\nrecreating tables for every single test.</li>\n<li>You should be able to execute in parallel to speed up when you\nhave thousands of tests. Dropping and creating tables per test\nwould not work in a parallel environment.</li>\n</ul>\n</blockquote>\n<p>For an example, I have a project with 600+ tests and it would take 2 and\nhalf minutes to execute running against SQLite. But when we swapped our\ntest configuration to execute against Postgres, testing took well over\nan hour. That is unacceptable!</p>\n<p>But running them in parallel will give us a huge speed up. Check out the\nresults of the tests running in single proc mode vs using all 4 cores:</p>\n<pre><code>$ py.test\n======= 616 passed in 143.67 seconds =======\n\n$ py.test -n4\n======= 616 passed in 68.12 seconds =======\n</code></pre>\n<h1>The right way</h1>\n<p>So what is the proper way to setup your tests? You should initialize the\ndatabase when you start your test runner and then use transactions to\nrollback any data changes your tests made. This allows you to keep a\nclean database for each test in a very efficient way.</p>\n<p>In py.test, you just have to create a file called conftest.py that looks\nsimilar to:</p>\n<pre><code><span>import</span> os\n\nROOT_PATH = os.path.dirname(__file__)\n\n<span>def</span> <span>pytest_sessionstart</span>():\n    <span>from</span> py.test <span>import</span> config\n\n    <span># Only run database setup on master (in case of xdist/multiproc mode)</span>\n    <span>if</span> <span>not</span> <span>hasattr</span>(config, <span>'slaveinput'</span>):\n        <span>from</span> models <span>import</span> initialize_sql\n        <span>from</span> pyramid.config <span>import</span> Configurator\n        <span>from</span> paste.deploy.loadwsgi <span>import</span> appconfig\n        <span>from</span> sqlalchemy <span>import</span> engine_from_config\n        <span>import</span> os\n\n        ROOT_PATH = os.path.dirname(__file__)\n        settings = appconfig(<span>'config:'</span> + os.path.join(ROOT_PATH, <span>'test.ini'</span>))\n        engine = engine_from_config(settings, prefix=<span>'sqlalchemy.'</span>)\n\n        <span>print</span> <span>'Creating the tables on the test database %s'</span> % engine\n\n        config = Configurator(settings=settings)\n        initialize_sql(settings, config)</code></pre>\n<p>With py.test, when you are running in parallel mode, the\npytest_sessionstart hook gets fired for each node, so we check that we\nare on the master node. Then we just grab our test.ini configuration\nfile and execute the initialize_sql function.</p>\n<p>Now that you have your initial test configuration finished, you have to\ndefine a base test class that does the transaction management in setUp\nand teardown.</p>\n<p>First, lets setup the Base testing class what will manage our\ntransactions:</p>\n<pre><code><span>import</span> unittest\n<span>from</span> pyramid <span>import</span> testing\n<span>from</span> paste.deploy.loadwsgi <span>import</span> appconfig\n\n<span>from</span> webtest <span>import</span> TestApp\n<span>from</span> mock <span>import</span> Mock\n\n<span>from</span> sqlalchemy <span>import</span> engine_from_config\n<span>from</span> sqlalchemy.orm <span>import</span> sessionmaker\n<span>from</span> app.db <span>import</span> Session\n<span>from</span> app.db <span>import</span> Entity  <span># base declarative object</span>\n<span>from</span> app <span>import</span> main\n<span>import</span> os\nhere = os.path.dirname(__file__)\nsettings = appconfig(<span>'config:'</span> + os.path.join(here, <span>'../../'</span>, <span>'test.ini'</span>))\n\n<span>class</span> <span>BaseTestCase</span>(unittest.TestCase):\n<span>    @classmethod</span>\n    <span>def</span> <span>setUpClass</span>(<span>cls</span>):\n        cls.engine = engine_from_config(settings, prefix=<span>'sqlalchemy.'</span>)\n        cls.Session = sessionmaker()\n\n    <span>def</span> <span>setUp</span>(<span>self</span>):\n        connection = self.engine.connect()\n\n        <span># begin a non-ORM transaction</span>\n        self.trans = connection.begin()\n\n        <span># bind an individual Session to the connection</span>\n        Session.configure(bind=connection)\n        self.session = self.Session(bind=connection)\n        Entity.session = self.session\n\n    <span>def</span> <span>tearDown</span>(<span>self</span>):\n        <span># rollback - everything that happened with the</span>\n        <span># Session above (including calls to commit())</span>\n        <span># is rolled back.</span>\n        testing.tearDown()\n        self.trans.rollback()\n        self.session.close()</code></pre>\n<p>This base test case will wrap all your sessions in an external\ntransaction so that you still have the ability to call flush/commit/etc\nand it will still be able to rollback any data changes you make.</p>\n<h1>Unit Tests</h1>\n<p>Now there are a few different types of tests you will want to run.\nFirst, you will want to do unit tests, which are small tests that only\ntest 1 thing at a time. This means you will skip the routes, templates,\netc. So let's setup our Unit Test Base class:</p>\n<pre><code><span>class</span> <span>UnitTestBase</span>(<span>BaseTestCase</span>):\n    <span>def</span> <span>setUp</span>(<span>self</span>):\n        self.config = testing.setUp(request=testing.DummyRequest())\n        <span>super</span>(UnitTestBase, self).setUp()\n\n    <span>def</span> <span>get_csrf_request</span>(<span>self, post=<span>None</span></span>):\n        csrf = <span>'abc'</span>\n\n        <span>if</span> <span>not</span> <span>u'csrf_token'</span> <span>in</span> post.keys():\n            post.update({\n                <span>'csrf_token'</span>: csrf\n            })\n\n        request = testing.DummyRequest(post)\n\n        request.session = Mock()\n        csrf_token = Mock()\n        csrf_token.return_value = csrf\n\n        request.session.get_csrf_token = csrf_token\n\n        <span>return</span> request</code></pre>\n<p>We built in a utility function to help us test requests that require a\ncsrf token as well. Here is how we would use this class:</p>\n<pre><code><span>class</span> <span>TestViews</span>(<span>UnitTestBase</span>):\n    <span>def</span> <span>test_login_fails_empty</span>(<span>self</span>):\n        <span>\"\"\" Make sure we can't login with empty credentials\"\"\"</span>\n        <span>from</span> app.accounts.views <span>import</span> LoginView\n        self.config.add_route(<span>'index'</span>, <span>'/'</span>)\n        self.config.add_route(<span>'dashboard'</span>, <span>'/'</span>)\n\n        request = testing.DummyRequest(post={\n            <span>'submit'</span>: <span>True</span>,\n        })\n\n        view = LoginView(request)\n        response = view.post()\n        errors = response[<span>'errors'</span>]\n\n        <span>assert</span> errors[<span>0</span>].node.name == <span>u'csrf_token'</span>\n        <span>assert</span> errors[<span>0</span>].msg == <span>u'Required'</span>\n        <span>assert</span> errors[<span>1</span>].node.name == <span>u'Username'</span>\n        <span>assert</span> errors[<span>1</span>].msg == <span>u'Required'</span>\n        <span>assert</span> errors[<span>2</span>].node.name == <span>u'Password'</span>\n        <span>assert</span> errors[<span>2</span>].msg == <span>u'Required'</span>\n\n\n    <span>def</span> <span>test_login_succeeds</span>(<span>self</span>):\n        <span>\"\"\" Make sure we can login \"\"\"</span>\n        admin = User(username=<span>'sontek'</span>, password=<span>'temp'</span>, kind=<span>u'admin'</span>)\n        admin.activated = <span>True</span>\n        self.session.add(admin)\n        self.session.flush()\n\n        <span>from</span> app.accounts.views <span>import</span> LoginView\n        self.config.add_route(<span>'index'</span>, <span>'/'</span>)\n        self.config.add_route(<span>'dashboard'</span>, <span>'/dashboard'</span>)\n\n        request = self.get_csrf_request(post={\n                <span>'submit'</span>: <span>True</span>,\n                <span>'Username'</span>: <span>'sontek'</span>,\n                <span>'Password'</span>: <span>'temp'</span>,\n            })\n\n        view = LoginView(request)\n        response = view.post()\n\n        <span>assert</span> response.status_int == <span>302</span></code></pre>\n<h1>Integration Tests</h1>\n<p>The second type of test you will want to write is an integration test.\nThis will integrate with the whole web framework and actually hit the\ndefine routes, render the templates, and actually test the full stack of\nyour application.</p>\n<p>Luckily this is pretty easy to do with Pyramid using WebTest:</p>\n<pre><code><span>class</span> <span>IntegrationTestBase</span>(<span>BaseTestCase</span>):\n<span>    @classmethod</span>\n    <span>def</span> <span>setUpClass</span>(<span>cls</span>):\n        cls.app = main({}, **settings)\n        <span>super</span>(IntegrationTestBase, cls).setUpClass()\n\n    <span>def</span> <span>setUp</span>(<span>self</span>):\n        self.app = TestApp(self.app)\n        self.config = testing.setUp()\n        <span>super</span>(IntegrationTestBase, self).setUp()</code></pre>\n<p>In setUpClass, we run the main function of the applications\n__init__.py that sets up the WSGI application and then we wrap it in\na TestApp that gives us the ability to call get/post on it.</p>\n<p>Here is an example of it in use:</p>\n<pre><code><span>class</span> <span>TestViews</span>(<span>IntegrationTestBase</span>):\n    <span>def</span> <span>test_get_login</span>(<span>self</span>):\n        <span>\"\"\" Call the login view, make sure routes are working \"\"\"</span>\n        res = self.app.get(<span>'/login'</span>)\n        self.assertEqual(res.status_int, <span>200</span>)\n\n    <span>def</span> <span>test_empty_login</span>(<span>self</span>):\n        <span>\"\"\" Empty login fails \"\"\"</span>\n        res = self.app.post(<span>'/login'</span>, {<span>'submit'</span>: <span>True</span>})\n\n        <span>assert</span> <span>\"There was a problem with your submission\"</span> <span>in</span> res.body\n        <span>assert</span> <span>\"Required\"</span> <span>in</span> res.body\n        <span>assert</span> res.status_int == <span>200</span>\n\n    <span>def</span> <span>test_valid_login</span>(<span>self</span>):\n        <span>\"\"\" Call the login view, make sure routes are working \"\"\"</span>\n        admin = User(username=<span>'sontek'</span>, password=<span>'temp'</span>, kind=<span>u'admin'</span>)\n        admin.activated = <span>True</span>\n        self.session.add(admin)\n        self.session.flush()\n\n        res = self.app.get(<span>'/login'</span>)\n\n        csrf = res.form.fields[<span>'csrf_token'</span>][<span>0</span>].value\n\n        res = self.app.post(<span>'/login'</span>,\n            {\n                <span>'submit'</span>: <span>True</span>,\n                <span>'Username'</span>: <span>'sontek'</span>,\n                <span>'Password'</span>: <span>'temp'</span>,\n                <span>'csrf_token'</span>: csrf\n            }\n        )\n\n        <span>assert</span> res.status_int == <span>302</span></code></pre>\n<h1>Problems with this approach</h1>\n<p>If a test causes an error that will prevent the transaction from rolling\nback, such as closing the engine, then this approach will leave your\ndatabase in a state that might cause other tests to fail.</p>\n<p>If this happens tracing the root cause could be difficult but you should\nbe able to just look at the first failed test unless you are running the\ntests in parallel.</p>\n<p>If you are good about writing and running your tests regularly you\nshould be able to catch individual tests causing issues like this fairly\nquickly.</p>\n<h1>Resources</h1>\n<p><a href=\"http://docs.pylonsproject.org/projects/pyramid/en/latest/narr/testing.html\">http://docs.pylonsproject.org/projects/pyramid/en/latest/narr/testing.html</a></p>\n<p><a href=\"http://www.sqlalchemy.org/docs/orm/session.html#joining-a-session-into-an-external-transaction\">http://www.sqlalchemy.org/docs/orm/session.html#joining-a-session-into-an-external-transaction</a></p>\n<p>John Anderson &#x3C;<a href=\"mailto:sontek@gmail.com\">sontek@gmail.com</a>> 2011</p>\n","category":"python\n","date":"2011-11-30T20:00:00-04:00","tags":"python, pyramid, sqlalchemy\n","title":"Writing tests for Pyramid and SQLAlchemy"}},"__N_SSG":true}