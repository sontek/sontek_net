{"pageProps":{"allPostsData":[{"id":["old","preparing_cloud_images_with_libvirt"],"path":"old/preparing_cloud_images_with_libvirt","contentHtml":"<p>This article will show you how to use libvirt to create base images that\ncan be uploaded to OpenStack.</p>\n<h1>Why would you want to do this?</h1>\n<p>Linux distributions like Fedora and Ubuntu already ship \"cloud\" images\nand most providers also have their own custom images for you to use, but\nI find it much more comforting to have full control of the software that\nis installed and I like the ability to easily apply new security patches\nto base images.</p>\n<p>I wouldn't use images to replace config management (CM) with something\nlike <a href=\"http://www.saltstack.com/\">Salt</a> or\n<a href=\"http://www.ansible.com/\">Ansible</a> but they are nice to give sane system\ndefaults in things like <code>grub.conf</code>, <code>sysctl.conf</code>, and shipping a Chef\nor Salt agent so that your CM engine can communicate with your server\nright away.</p>\n<h1>Setting up your environment</h1>\n<p>The first thing you need to do is get a minimal install disk for the\nLinux distribution you want to use. I prefer using Fedora netinst disks\nbut another popular option is Ubuntu Server.</p>\n<p>To get the latest Fedora here, you can choose \"netinst\" under Direct\nDownloads: <a href=\"http://fedoraproject.org/en/get-fedora-all\">http://fedoraproject.org/en/get-fedora-all</a></p>\n<p>To get the latest Ubuntu you can go here:\n<a href=\"http://www.ubuntu.com/download/server\">http://www.ubuntu.com/download/server</a></p>\n<p>Once you have acquired your distribution of choice you just need to\nverify that you have <code>virt-install</code> and <code>virt-viewer</code> installed:</p>\n<p>Fedora:</p>\n<pre><code>yum install virt-install virt-viewer</code></pre>\n<p>Ubuntu:</p>\n<pre><code>apt-get install virtinst virt-viewer</code></pre>\n<p>If you prefer a graphical user interface, you may use <code>virt-manager</code>\ninstead, but I try to keep everything in the CLI; that way it can be\nrepeated easily.</p>\n<h1>Preparing your disk</h1>\n<p>Now that you have a base ISO and the tools necessary, let's get started\nby creating a disk to install the virtual server into. Resizing an image\nisn't an impossible task but it is much easier to choose a reasonably\nsized disk for the purpose it will be used for.</p>\n<p>I primarily use 8 GB disks -- that way we can fit all the system\ncomponents required as well as our own web applications. Any large files\nshould be placed in a SAN or something like Dreamhost's dreamobjects.</p>\n<p>The other big decision you must make upfront is what disk format you\nwant to use -- the trade-off is disk space vs performance. The two\nprimary formats are qcow2 (QEMU Copy on Write) and Raw. qcow2 is great\nif you have limited disk space and don't want to allocate the full 8 GB\nup front. Raw is preferred if you want the best performance.</p>\n<p>If you choose qcow2, you'll also need to make sure you have <code>qemu-img</code>:</p>\n<p>Fedora:</p>\n<pre><code>yum install qemu-img</code></pre>\n<p>Ubuntu:</p>\n<pre><code>apt-get install qemu-utils</code></pre>\n<p>Create a raw disk:</p>\n<pre><code>fallocate -l 8192M server.img</code></pre>\n<p>Create a qcow2 disk:</p>\n<pre><code>qemu-img create -f qcow2 server.qcow2 8G</code></pre>\n<h1>Installing your distribution onto the disk</h1>\n<p>We will use the <code>virt-install</code> command to get the distribution installed\nonto the disk image.</p>\n<p>To install Fedora on a qcow2 disk image:</p>\n<pre><code>virt-install --name base_server --ram 1024 --cdrom=./Fedora-20-x86_64-netinst.iso \\\n--disk path=./server.qcow2,format=qcow2</code></pre>\n<p>To install Ubuntu Server on a raw disk image:</p>\n<pre><code>virt-install --name base_server --ram 1024 --cdrom=./ubuntu-12.04.4-server-amd64.iso \\\n--disk path=./server.img,format=raw</code></pre>\n<p>You should follow the standard install steps that you normally would\nwhen setting up your distribution. But here are some tips for each:</p>\n<p>Fedora:</p>\n<ul>\n<li>Choose minimal install -- by default it selects \"GNOME\".</li>\n</ul>\n<p>Ubuntu:</p>\n<ul>\n<li>\n<p>Be sure to select OpenSSH server -- it won't install it by\ndefault.</p>\n</li>\n<li>\n<p>On Ubuntu 12.04, there is a bug that makes it hang after running\n<code>fsck</code>. You will need to edit grub to get it to boot, hit _<a href=\"\">e</a> at\nthe boot prompt and add \"nomodeset\" on the linux line. You will\nknow that you need to do this if your boot hangs on fsck:</p>\n<pre><code>fsck from util-linux 2.20.1\n/dev/mapper/ubuntu--vg-root: clean, 57106/441504 files, 286779/1764352 blocks\n/dev/sda1: clean, 230/62248 files, 39833/248832 blocks</code></pre>\n</li>\n</ul>\n<h1>Preparing image for openstack</h1>\n<p>To prepare a virtual machine for the cloud, you will need to install the\n<code>cloud-init</code> package, which allows the cloud providers to inject certain\nsystem settings when creating servers based on the image. These are\nthings like hostname and ssh keys.</p>\n<p>On Fedora:</p>\n<pre><code>yum install cloud-init</code></pre>\n<p>On Ubuntu:</p>\n<pre><code>apt-get install cloud-init</code></pre>\n<p>Then you need to just configure <code>cloud-init</code> by editing\n<code>/etc/cloud/cloud.cfg</code> and update the <code>datasources_list</code> section to\ninclude EC2. OpenStack uses EC2 metadata for <code>cloud-init</code>.</p>\n<p>You should also verify the user setting in this same config and define\nthe user you plan to use, it will be where the <code>authorized_keys</code> file is\nsetup for when the cloud provider injects your SSH key into the server.</p>\n<p><code>cloud-init</code> will not create the user for you, it will just assign the\nSSH keypair and reset the password. So make sure the user defined in\n<code>cloud.cfg</code> is also created on the system.</p>\n<p>Once you have your <code>cloud-init</code> settings the way you want them, just\nshutdown and run the <code>virt-sysprep</code> command.</p>\n<p>On the guest machine:</p>\n<pre><code>shutdown -h now</code></pre>\n<p>On the host machine:</p>\n<pre><code>virt-sysprep -d base_server</code></pre>\n<h1>Uploading your image to OpenStack</h1>\n<p>Using the glance API it is very straightforward to upload the image to\nOpenStack. Just run the following command:</p>\n<pre><code>glance image-create --name base_server --disk-format=qcow2 \\\n--container-format=bare --is-public=True --file server.qcow2 --progress</code></pre>\n<p>Once the image upload completes you will be able to use it immediately\nwithin nova. You can reference it by name or by the id from [glance\nimage-list]{.title-ref}.</p>\n<p>To create your first instance from the image:</p>\n<pre><code>nova boot --flavor m1.tiny --image base_server --key-name devops \\\n--security-groups free_for_all test_server</code></pre>\n<p>Obviously the security groups, key name, and flavors are based on your\ninstallation of OpenStack but can all easily be queried from the nova\nAPI:</p>\n<pre><code>nova flavor-list\nnova secgroup-list\nnova keypair-list</code></pre>\n<p>And you are done! You'll be able to re-use your new image as a base for\nall new instances you spin up in openstack!</p>\n","category":"devops\n","date":"2014-08-02T20:00:00-04:00","tags":"linux, openstack, libvirt\n","title":"Preparing custom images for OpenStack"},{"id":["old","writing_tests_for_pyramid_and_sqlalchemy"],"path":"old/writing_tests_for_pyramid_and_sqlalchemy","contentHtml":"<p>TL;DR: Putting it all together, the full code can be found here:\n<a href=\"https://gist.github.com/1420255\">https://gist.github.com/1420255</a></p>\n<h1>Intro</h1>\n<p>Pyramid's documentation doesn't cover the preferred way to test with\nSQLAlchemy, because Pyramid tries to stay out of your way and allow you\nto make your own decisions. However, I feel i'ts necessary to document\nwhat I think is the best way to test.</p>\n<p>When I first started writing tests with SQLAlchemy I found plenty of\nexamples of how to to get started by doing something like this:</p>\n<pre><code><span>from</span> db <span>import</span> session <span># probably a contextbound sessionmaker</span>\n<span>from</span> db <span>import</span> model\n\n<span>from</span> sqlalchemy <span>import</span> create_engine\n\n<span>def</span> <span>setup</span>():\n    engine = create_engine(<span>'sqlite:///test.db'</span>)\n    session.configure(bind=engine)\n    model.metadata.create_all(engine)\n\n<span>def</span> <span>teardown</span>():\n    model.metadata.drop_all(engine)\n\n<span>def</span> <span>test_something</span>():\n    <span>pass</span></code></pre>\n<p>I have seen this done so many times, but I feel there is so much wrong\nwith it! So let's establish some base rules when testing:</p>\n<blockquote>\n<ul>\n<li>Always test your system like it would be used in production.\nSQLite does not enforce the same rules or have the same features\nas Postgres or MySQL and will allow tests to pass that would\notherwise fail in production.</li>\n<li>Tests should be fast! You should be writing tests for all your\ncode. This is the main reason people do test against SQLite, but\nwe can't violate rule number one. We have to make sure tests\nagainst Postgres are fast, so we shouldn't be tearing down and\nrecreating tables for every single test.</li>\n<li>You should be able to execute in parallel to speed up when you\nhave thousands of tests. Dropping and creating tables per test\nwould not work in a parallel environment.</li>\n</ul>\n</blockquote>\n<p>For an example, I have a project with 600+ tests and it would take 2 and\nhalf minutes to execute running against SQLite. But when we swapped our\ntest configuration to execute against Postgres, testing took well over\nan hour. That is unacceptable!</p>\n<p>But running them in parallel will give us a huge speed up. Check out the\nresults of the tests running in single proc mode vs using all 4 cores:</p>\n<pre><code>$ py.test\n======= 616 passed in 143.67 seconds =======\n\n$ py.test -n4\n======= 616 passed in 68.12 seconds =======\n</code></pre>\n<h1>The right way</h1>\n<p>So what is the proper way to setup your tests? You should initialize the\ndatabase when you start your test runner and then use transactions to\nrollback any data changes your tests made. This allows you to keep a\nclean database for each test in a very efficient way.</p>\n<p>In py.test, you just have to create a file called conftest.py that looks\nsimilar to:</p>\n<pre><code><span>import</span> os\n\nROOT_PATH = os.path.dirname(__file__)\n\n<span>def</span> <span>pytest_sessionstart</span>():\n    <span>from</span> py.test <span>import</span> config\n\n    <span># Only run database setup on master (in case of xdist/multiproc mode)</span>\n    <span>if</span> <span>not</span> <span>hasattr</span>(config, <span>'slaveinput'</span>):\n        <span>from</span> models <span>import</span> initialize_sql\n        <span>from</span> pyramid.config <span>import</span> Configurator\n        <span>from</span> paste.deploy.loadwsgi <span>import</span> appconfig\n        <span>from</span> sqlalchemy <span>import</span> engine_from_config\n        <span>import</span> os\n\n        ROOT_PATH = os.path.dirname(__file__)\n        settings = appconfig(<span>'config:'</span> + os.path.join(ROOT_PATH, <span>'test.ini'</span>))\n        engine = engine_from_config(settings, prefix=<span>'sqlalchemy.'</span>)\n\n        <span>print</span> <span>'Creating the tables on the test database %s'</span> % engine\n\n        config = Configurator(settings=settings)\n        initialize_sql(settings, config)</code></pre>\n<p>With py.test, when you are running in parallel mode, the\npytest_sessionstart hook gets fired for each node, so we check that we\nare on the master node. Then we just grab our test.ini configuration\nfile and execute the initialize_sql function.</p>\n<p>Now that you have your initial test configuration finished, you have to\ndefine a base test class that does the transaction management in setUp\nand teardown.</p>\n<p>First, lets setup the Base testing class what will manage our\ntransactions:</p>\n<pre><code><span>import</span> unittest\n<span>from</span> pyramid <span>import</span> testing\n<span>from</span> paste.deploy.loadwsgi <span>import</span> appconfig\n\n<span>from</span> webtest <span>import</span> TestApp\n<span>from</span> mock <span>import</span> Mock\n\n<span>from</span> sqlalchemy <span>import</span> engine_from_config\n<span>from</span> sqlalchemy.orm <span>import</span> sessionmaker\n<span>from</span> app.db <span>import</span> Session\n<span>from</span> app.db <span>import</span> Entity  <span># base declarative object</span>\n<span>from</span> app <span>import</span> main\n<span>import</span> os\nhere = os.path.dirname(__file__)\nsettings = appconfig(<span>'config:'</span> + os.path.join(here, <span>'../../'</span>, <span>'test.ini'</span>))\n\n<span>class</span> <span>BaseTestCase</span>(unittest.TestCase):\n<span>    @classmethod</span>\n    <span>def</span> <span>setUpClass</span>(<span>cls</span>):\n        cls.engine = engine_from_config(settings, prefix=<span>'sqlalchemy.'</span>)\n        cls.Session = sessionmaker()\n\n    <span>def</span> <span>setUp</span>(<span>self</span>):\n        connection = self.engine.connect()\n\n        <span># begin a non-ORM transaction</span>\n        self.trans = connection.begin()\n\n        <span># bind an individual Session to the connection</span>\n        Session.configure(bind=connection)\n        self.session = self.Session(bind=connection)\n        Entity.session = self.session\n\n    <span>def</span> <span>tearDown</span>(<span>self</span>):\n        <span># rollback - everything that happened with the</span>\n        <span># Session above (including calls to commit())</span>\n        <span># is rolled back.</span>\n        testing.tearDown()\n        self.trans.rollback()\n        self.session.close()</code></pre>\n<p>This base test case will wrap all your sessions in an external\ntransaction so that you still have the ability to call flush/commit/etc\nand it will still be able to rollback any data changes you make.</p>\n<h1>Unit Tests</h1>\n<p>Now there are a few different types of tests you will want to run.\nFirst, you will want to do unit tests, which are small tests that only\ntest 1 thing at a time. This means you will skip the routes, templates,\netc. So let's setup our Unit Test Base class:</p>\n<pre><code><span>class</span> <span>UnitTestBase</span>(<span>BaseTestCase</span>):\n    <span>def</span> <span>setUp</span>(<span>self</span>):\n        self.config = testing.setUp(request=testing.DummyRequest())\n        <span>super</span>(UnitTestBase, self).setUp()\n\n    <span>def</span> <span>get_csrf_request</span>(<span>self, post=<span>None</span></span>):\n        csrf = <span>'abc'</span>\n\n        <span>if</span> <span>not</span> <span>u'csrf_token'</span> <span>in</span> post.keys():\n            post.update({\n                <span>'csrf_token'</span>: csrf\n            })\n\n        request = testing.DummyRequest(post)\n\n        request.session = Mock()\n        csrf_token = Mock()\n        csrf_token.return_value = csrf\n\n        request.session.get_csrf_token = csrf_token\n\n        <span>return</span> request</code></pre>\n<p>We built in a utility function to help us test requests that require a\ncsrf token as well. Here is how we would use this class:</p>\n<pre><code><span>class</span> <span>TestViews</span>(<span>UnitTestBase</span>):\n    <span>def</span> <span>test_login_fails_empty</span>(<span>self</span>):\n        <span>\"\"\" Make sure we can't login with empty credentials\"\"\"</span>\n        <span>from</span> app.accounts.views <span>import</span> LoginView\n        self.config.add_route(<span>'index'</span>, <span>'/'</span>)\n        self.config.add_route(<span>'dashboard'</span>, <span>'/'</span>)\n\n        request = testing.DummyRequest(post={\n            <span>'submit'</span>: <span>True</span>,\n        })\n\n        view = LoginView(request)\n        response = view.post()\n        errors = response[<span>'errors'</span>]\n\n        <span>assert</span> errors[<span>0</span>].node.name == <span>u'csrf_token'</span>\n        <span>assert</span> errors[<span>0</span>].msg == <span>u'Required'</span>\n        <span>assert</span> errors[<span>1</span>].node.name == <span>u'Username'</span>\n        <span>assert</span> errors[<span>1</span>].msg == <span>u'Required'</span>\n        <span>assert</span> errors[<span>2</span>].node.name == <span>u'Password'</span>\n        <span>assert</span> errors[<span>2</span>].msg == <span>u'Required'</span>\n\n\n    <span>def</span> <span>test_login_succeeds</span>(<span>self</span>):\n        <span>\"\"\" Make sure we can login \"\"\"</span>\n        admin = User(username=<span>'sontek'</span>, password=<span>'temp'</span>, kind=<span>u'admin'</span>)\n        admin.activated = <span>True</span>\n        self.session.add(admin)\n        self.session.flush()\n\n        <span>from</span> app.accounts.views <span>import</span> LoginView\n        self.config.add_route(<span>'index'</span>, <span>'/'</span>)\n        self.config.add_route(<span>'dashboard'</span>, <span>'/dashboard'</span>)\n\n        request = self.get_csrf_request(post={\n                <span>'submit'</span>: <span>True</span>,\n                <span>'Username'</span>: <span>'sontek'</span>,\n                <span>'Password'</span>: <span>'temp'</span>,\n            })\n\n        view = LoginView(request)\n        response = view.post()\n\n        <span>assert</span> response.status_int == <span>302</span></code></pre>\n<h1>Integration Tests</h1>\n<p>The second type of test you will want to write is an integration test.\nThis will integrate with the whole web framework and actually hit the\ndefine routes, render the templates, and actually test the full stack of\nyour application.</p>\n<p>Luckily this is pretty easy to do with Pyramid using WebTest:</p>\n<pre><code><span>class</span> <span>IntegrationTestBase</span>(<span>BaseTestCase</span>):\n<span>    @classmethod</span>\n    <span>def</span> <span>setUpClass</span>(<span>cls</span>):\n        cls.app = main({}, **settings)\n        <span>super</span>(IntegrationTestBase, cls).setUpClass()\n\n    <span>def</span> <span>setUp</span>(<span>self</span>):\n        self.app = TestApp(self.app)\n        self.config = testing.setUp()\n        <span>super</span>(IntegrationTestBase, self).setUp()</code></pre>\n<p>In setUpClass, we run the main function of the applications\n__init__.py that sets up the WSGI application and then we wrap it in\na TestApp that gives us the ability to call get/post on it.</p>\n<p>Here is an example of it in use:</p>\n<pre><code><span>class</span> <span>TestViews</span>(<span>IntegrationTestBase</span>):\n    <span>def</span> <span>test_get_login</span>(<span>self</span>):\n        <span>\"\"\" Call the login view, make sure routes are working \"\"\"</span>\n        res = self.app.get(<span>'/login'</span>)\n        self.assertEqual(res.status_int, <span>200</span>)\n\n    <span>def</span> <span>test_empty_login</span>(<span>self</span>):\n        <span>\"\"\" Empty login fails \"\"\"</span>\n        res = self.app.post(<span>'/login'</span>, {<span>'submit'</span>: <span>True</span>})\n\n        <span>assert</span> <span>\"There was a problem with your submission\"</span> <span>in</span> res.body\n        <span>assert</span> <span>\"Required\"</span> <span>in</span> res.body\n        <span>assert</span> res.status_int == <span>200</span>\n\n    <span>def</span> <span>test_valid_login</span>(<span>self</span>):\n        <span>\"\"\" Call the login view, make sure routes are working \"\"\"</span>\n        admin = User(username=<span>'sontek'</span>, password=<span>'temp'</span>, kind=<span>u'admin'</span>)\n        admin.activated = <span>True</span>\n        self.session.add(admin)\n        self.session.flush()\n\n        res = self.app.get(<span>'/login'</span>)\n\n        csrf = res.form.fields[<span>'csrf_token'</span>][<span>0</span>].value\n\n        res = self.app.post(<span>'/login'</span>,\n            {\n                <span>'submit'</span>: <span>True</span>,\n                <span>'Username'</span>: <span>'sontek'</span>,\n                <span>'Password'</span>: <span>'temp'</span>,\n                <span>'csrf_token'</span>: csrf\n            }\n        )\n\n        <span>assert</span> res.status_int == <span>302</span></code></pre>\n<h1>Problems with this approach</h1>\n<p>If a test causes an error that will prevent the transaction from rolling\nback, such as closing the engine, then this approach will leave your\ndatabase in a state that might cause other tests to fail.</p>\n<p>If this happens tracing the root cause could be difficult but you should\nbe able to just look at the first failed test unless you are running the\ntests in parallel.</p>\n<p>If you are good about writing and running your tests regularly you\nshould be able to catch individual tests causing issues like this fairly\nquickly.</p>\n<h1>Resources</h1>\n<p><a href=\"http://docs.pylonsproject.org/projects/pyramid/en/latest/narr/testing.html\">http://docs.pylonsproject.org/projects/pyramid/en/latest/narr/testing.html</a></p>\n<p><a href=\"http://www.sqlalchemy.org/docs/orm/session.html#joining-a-session-into-an-external-transaction\">http://www.sqlalchemy.org/docs/orm/session.html#joining-a-session-into-an-external-transaction</a></p>\n<p>John Anderson &#x3C;<a href=\"mailto:sontek@gmail.com\">sontek@gmail.com</a>> 2011</p>\n","category":"python\n","date":"2011-11-30T20:00:00-04:00","tags":"python, pyramid, sqlalchemy\n","title":"Writing tests for Pyramid and SQLAlchemy"},{"id":["old","turning_vim_into_a_modern_python_ide"],"path":"old/turning_vim_into_a_modern_python_ide","contentHtml":"<p>::: {.contents}\n:::</p>\n<p>TL;DR:</p>\n<pre><code>$ git clone https://github.com/sontek/dotfiles.git\n$ cd dotfiles\n$ ./install.sh vim\n</code></pre>\n<h1>Intro</h1>\n<p>Back in 2008, I wrote the article <a href=\"http://sontek.net/python-with-a-modular-ide-vim\">Python with a modular IDE\n(Vim)</a>. Years later, I\nhave people e-mailing me and commenting daily asking for more\ninformation, even though most of the information in it is outdated. Here\nis the modern way to work with Python and Vim to achieve the perfect\nenvironment.</p>\n<p>Because one of the most important parts about a development environment\nis the ability to easily reproduce across machines, we are going to\nstore our vim configuration in git:</p>\n<pre><code>$ mkdir ~/.vim/\n$ mkdir ~/.vim/{autoload,bundle}\n$ cd ~/.vim/\n$ git init\n</code></pre>\n<p>The purpose of the autoload directory is to automatically load the vim\nplugin <a href=\"https://github.com/tpope/vim-pathogen\">Pathogen</a>, which we'll\nthen use to load all other plugins that are located in the bundle\ndirectory. So download pathogen and put it in your autoload folder.</p>\n<p>You'll need to add the following to your ~/.vimrc so that pathogen\nwill be loaded properly. Filetype detection must be off when you run the\ncommands so its best to execute them first:</p>\n<pre><code>filetype off\ncall pathogen#runtime_append_all_bundles()\ncall pathogen#helptags()\n</code></pre>\n<p>Now lets add all of the vim plugins we plan on using as submodules to\nour git repository:</p>\n<pre><code>git submodule add http://github.com/tpope/vim-fugitive.git bundle/fugitive\ngit submodule add https://github.com/msanders/snipmate.vim.git bundle/snipmate\ngit submodule add https://github.com/tpope/vim-surround.git bundle/surround\ngit submodule add https://github.com/tpope/vim-git.git bundle/git\ngit submodule add https://github.com/ervandew/supertab.git bundle/supertab\ngit submodule add https://github.com/sontek/minibufexpl.vim.git bundle/minibufexpl\ngit submodule add https://github.com/wincent/Command-T.git bundle/command-t\ngit submodule add https://github.com/mitechie/pyflakes-pathogen.git\ngit submodule add https://github.com/mileszs/ack.vim.git bundle/ack\ngit submodule add https://github.com/sjl/gundo.vim.git bundle/gundo\ngit submodule add https://github.com/fs111/pydoc.vim.git bundle/pydoc\ngit submodule add https://github.com/vim-scripts/pep8.git bundle/pep8\ngit submodule add https://github.com/alfredodeza/pytest.vim.git bundle/py.test\ngit submodule add https://github.com/reinh/vim-makegreen bundle/makegreen\ngit submodule add https://github.com/vim-scripts/TaskList.vim.git bundle/tasklist\ngit submodule add https://github.com/vim-scripts/The-NERD-tree.git bundle/nerdtree\ngit submodule add https://github.com/sontek/rope-vim.git bundle/ropevim\ngit submodule init\ngit submodule update\ngit submodule foreach git submodule init\ngit submodule foreach git submodule update\n</code></pre>\n<p>Thats it! Now that we've got our vim configuration in git!</p>\n<p>Now lets look at how to use each of these plugins to improve the power\nof vim:</p>\n<h1>Basic Editing and Debugging</h1>\n<h2>Code Folding</h2>\n<p>Lets first enable code folding. This makes it a lot easier to organize\nyour code and hide portions that you aren't interested in working on.\nThis is quite easy for Python, since whitespace is required.</p>\n<p>In your ~/.vimrc just add:</p>\n<pre><code>set foldmethod=indent\nset foldlevel=99\n</code></pre>\n<p>Then you will be able to be inside a method and type 'za' to open and\nclose a fold.</p>\n<h2>Window Splits</h2>\n<p>Sometimes code folding isn't enough; you may need to start opening up\nmultiple windows and working on multiple files at once or different\nlocations within the same file. To do this in vim, you can use these\nshortcuts:</p>\n<pre><code>Vertical Split : Ctrl+w + v\nHorizontal Split: Ctrl+w + s\nClose current windows: Ctrl+w + q\n</code></pre>\n<p>I also like to bind Ctrl+&#x3C;movement> keys to move around the windows,\ninstead of using Ctrl+w + &#x3C;movement>:</p>\n<pre><code>map &#x3C;c-j> &#x3C;c-w>j\nmap &#x3C;c-k> &#x3C;c-w>k\nmap &#x3C;c-l> &#x3C;c-w>l\nmap &#x3C;c-h> &#x3C;c-w>h\n</code></pre>\n<p><img src=\"http://i.imgur.com/krj0l.png\" alt=\"image\"></p>\n<h2>Snippets</h2>\n<p>The next tweak that really speeds up development is using snipmate.\nWe've already included it in our bundle/ folder so its already enabled.\nTry opening up a python file and typing 'def&#x3C;tab>'. It should stub\nout a method definition for you and allow you to tab through and fill\nout the arguments, doc string, etc.</p>\n<p>I also like to create my own snippets folder to put in some custom\nsnippets:</p>\n<pre><code>$ mkdir ~/.vim/snippets\n$ vim ~/.vim/snippets/python.snippets\n</code></pre>\n<p>Put this in the file:</p>\n<pre><code>snippet pdb\n    import pdb; pdb.set_trace()\n</code></pre>\n<p>Now you can type pdb&#x3C;tab> and it'll insert your breakpoint!</p>\n<h2>Task lists</h2>\n<p>Another really useful thing is to mark some of your code as TODO or\nFIXME! I know we all like to think we write perfect code, but sometimes\nyou just have to settle and leave a note for yourself to come back\nlater. One of the plugins we included was the tasklist plugin that will\nallow us to search all open buffers for things to fix. Just add a\nmapping to open it in ~/.vimrc:</p>\n<pre><code>map &#x3C;leader>td &#x3C;Plug>TaskList\n</code></pre>\n<p>Now you can hit &#x3C;leader>td to open your task list and hit 'q' to\nclose it. You can also hit enter on the task to jump to the buffer and\nline that it is placed on.</p>\n<h2>Revision History</h2>\n<p>The final basic editing tweak I suggest everyone start utilizing is the\nGundo plugin. It'll allow you to view diff's of every save on a file\nyou've made and allow you to quickly revert back and forth:</p>\n<p><img src=\"http://i.imgur.com/2NrPS.png\" alt=\"image\"></p>\n<p>Just bind a key in your .vimrc to toggle the Gundo window:</p>\n<pre><code>map &#x3C;leader>g :GundoToggle&#x3C;CR>\n</code></pre>\n<h1>Syntax Highlighting and Validation</h1>\n<p>Simply enable syntax highlighting in your ~/.vimrc:</p>\n<pre><code>syntax on                           \" syntax highlighing\nfiletype on                          \" try to detect filetypes\nfiletype plugin indent on    \" enable loading indent file for filetype\n</code></pre>\n<p>Because we enabled pyflakes when we added it as a submodule in\n~/.vim/bundle, it will notify you about unused imports and invalid\nsyntax. It will save you a lot of time saving and running just to find\nout you missed a colon. I like to tell it not use the quickfix window:</p>\n<pre><code>let g:pyflakes_use_quickfix = 0\n</code></pre>\n<p><img src=\"http://i.imgur.com/ZfjFe.png\" alt=\"image\"></p>\n<h2>Pep8</h2>\n<p>The final plugin that really helps validate your code is the pep8\nplugin, it'll make sure your code is consistent across all projects.\nAdd a key mapping to your ~/.vimrc and then you'll be able to jump to\neach of the pep8 violations in the quickfix window:</p>\n<pre><code>let g:pep8_map='&#x3C;leader>8'\n</code></pre>\n<p><img src=\"http://i.imgur.com/VU9AB.png\" alt=\"image\"></p>\n<h1>Tab Completion and Documentation</h1>\n<p>Vim has many different code completion options. We are going to use the\nSuperTab plugin to check the context of the code you are working on and\nchoose the best for the situation. We've already enabled the SuperTab\nplugin in the bundle/ folder, so we just have to configure it to be\ncontext sensitive and to enable omni code completion in your ~/.vimrc:</p>\n<pre><code>au FileType python set omnifunc=pythoncomplete#Complete\nlet g:SuperTabDefaultCompletionType = \"context\"\n</code></pre>\n<p>Now we just enable the menu and pydoc preview to get the most useful\ninformation out of the code completion:</p>\n<pre><code>set completeopt=menuone,longest,preview\n</code></pre>\n<p><img src=\"http://i.imgur.com/g4lxP.png\" alt=\"image\"></p>\n<p>We also enabled the pydoc plugin at the beginning with all the\nsubmodules; that gives us the ability to hit &#x3C;leader>pw when our\ncursor is on a module and have a new window open with the whole\ndocumentation page for it.</p>\n<h1>Code Navigation</h1>\n<h2>Buffers</h2>\n<p>The most important part about navigating code within vim, is to\ncompletely understand how to use buffers. There is no reason to use\ntabs. Open files with :e &#x3C;filename> to place in a buffer. We already\ninstalled the minibufexpl plugin, so you will already visually see every\nbuffer opened. You can also get a list of them doing :buffers.</p>\n<p>You can switch between the buffers using b&#x3C;number>, such as :b1 for\nthe first buffer. You can also use its name to match, so you can type :b\nmod&#x3C;tab> to autocomplete opening the models.py buffer. You need to\nmake sure you are using the minibufexpl from my github since it has\npatches that make it much better to work with.</p>\n<p>To close a buffer you use :bd or :bw.</p>\n<h2>Fuzzy Text File Search</h2>\n<p>To make finding and opening files within your project even easier, we\nare going to use the command-t plugin. It does have some parts that need\nto be compiled, so its not already installed by adding it as a\nsubmodule. Go to your ~/.vim/bundle/command-t folder and run 'rake\nmake'. Yes you need ruby installed. By default, command-t is bound to\n&#x3C;leader>t. This will use fuzzy text matching to find any file in your\nproject.</p>\n<p>It also supports searching only through opened buffers, instead of files\nusing &#x3C;leader>b.</p>\n<p><img src=\"http://i.imgur.com/hUcSl.png\" alt=\"image\"></p>\n<h2>File Browser</h2>\n<p>NERD Tree is a project file browser. I must admit I used this heavily\nback when I was migrating from Visual Studio and used to the Solution\nExplorer, but I rarely use it anymore. Command-T is usually all you'll\nneed. It is useful when you are getting to know a new codebase for the\nfirst time though. Lets bind a shortcut key for opening it:</p>\n<pre><code>map &#x3C;leader>n :NERDTreeToggle&#x3C;CR>\n</code></pre>\n<p><img src=\"http://i.imgur.com/R4ZzQ.png\" alt=\"image\"></p>\n<h2>Refactoring and Go to definition</h2>\n<p>Ropevim is also a great tool that will allow you to navigate around your\ncode. It supports automatically inserting import statements, goto\ndefinition, refactoring, and code completion. You'll really want to\nread up on everything it does, but the two big things I use it for is to\njump to function or class definitions quickly and to rename things\n(including all their references).</p>\n<p>For instance, if you are using django and you place your cursor over the\nclass models.Model you reference and then called :RopeGotoDefintion, it\nwould jump you straight to the django library to that class definition.\nWe already have it installed in our bundles, so we bind it to a key to\nuse it:</p>\n<pre><code>map &#x3C;leader>j :RopeGotoDefinition&#x3C;CR>\nmap &#x3C;leader>r :RopeRename&#x3C;CR>\n</code></pre>\n<h2>Searching</h2>\n<p>The final tool that really speeds up navigating your code is the Ack\nplugin. Ack is similar to grep, but much better in my opinion. You can\nfuzzy text search for anything in your code (variable name, class,\nmethod, etc) and it'll give you a list of files and line numbers where\nthey are defined so you can quickly cycle through them. Just bind the\nsearching to a key:</p>\n<pre><code>nmap &#x3C;leader>a &#x3C;Esc>:Ack!\n</code></pre>\n<p>We use ! at the end of it so it doesn't open the first result\nautomatically.</p>\n<h1>Integration with Git</h1>\n<p>We installed 2 plugins, git.vim and fugitive, that give us all the\nintegration we need. Git.vim will provide us syntax highlighting for git\nconfiguration files; fugitive provides a great interface for interacting\nwith git including getting diffs, status updates, committing, and moving\nfiles.</p>\n<p>Fugitive also allows you to view what branch you are working in directly\nfrom vim. Add this to your statusline in ~/.vimrc:</p>\n<pre><code>%{fugitive#statusline()}\n</code></pre>\n<p>The big commands you need to know:</p>\n<ul>\n<li><strong>Gblame</strong>: This allows you to view a line by line comparison of who\nthe last person to touch that line of code is.</li>\n<li><strong>Gwrite</strong>: This will stage your file for commit, basically doing\ngit add &#x3C;filename></li>\n<li><strong>Gread</strong>: This will basically run a git checkout &#x3C;filename></li>\n<li><strong>Gcommit</strong>: This will just run git commit. Since its in a vim\nbuffer, you can use keyword completion (Ctrl-N), like\ntest_all&#x3C;Ctrl-N> to find the method name in your buffer and\ncomplete it for the commit message. You can also use + and - on the\nfilenames in the message to stage/unstage them for the commit.</li>\n</ul>\n<p><img src=\"http://i.imgur.com/NuRRj.png\" alt=\"image\"></p>\n<h1>Test Integration</h1>\n<h2>django nose</h2>\n<p>Test runner integration really depends on the testing library you are\nusing and what type of tests you are running but we included a great\ngeneric plugin called MakeGreen that executes off of vim's makeprg\nvariable. So for instance, if you are using django with django-nose you\ncould define a shortcut key in your ~/.vimrc like this:</p>\n<pre><code>map &#x3C;leader>dt :set makeprg=python\\ manage.py\\ test\\|:call MakeGreen()&#x3C;CR>\n</code></pre>\n<p>This will just give you a green bar at the bottom of vim if your test\npassed or a red bar with the message of the failed test if it doesn't.\nVery simple.</p>\n<h2>py.test</h2>\n<p>I also included the py.test vim plugin for those who prefer it. This\nplugin has a lot more functionality including executing individual tests\nby class, file, or method. You can also cycle through the individual\nassertion errors. I have the following bindings:</p>\n<pre><code>\" Execute the tests\nnmap &#x3C;silent>&#x3C;Leader>tf &#x3C;Esc>:Pytest file&#x3C;CR>\nnmap &#x3C;silent>&#x3C;Leader>tc &#x3C;Esc>:Pytest class&#x3C;CR>\nnmap &#x3C;silent>&#x3C;Leader>tm &#x3C;Esc>:Pytest method&#x3C;CR>\n\" cycle through test errors\nnmap &#x3C;silent>&#x3C;Leader>tn &#x3C;Esc>:Pytest next&#x3C;CR>\nnmap &#x3C;silent>&#x3C;Leader>tp &#x3C;Esc>:Pytest previous&#x3C;CR>\nnmap &#x3C;silent>&#x3C;Leader>te &#x3C;Esc>:Pytest error&#x3C;CR>\n</code></pre>\n<p><img src=\"http://i.imgur.com/RAE7v.png\" alt=\"image\"></p>\n<h1>Virtualenv</h1>\n<p>Vim doesn't realize that you are in a virtualenv so it wont give you\ncode completion for libraries only installed there. Add the following\nscript to your ~/.vimrc to fix it:</p>\n<pre><code>\" Add the virtualenv's site-packages to vim path\npy &#x3C;&#x3C; EOF\nimport os.path\nimport sys\nimport vim\nif 'VIRTUAL_ENV' in os.environ:\n    project_base_dir = os.environ['VIRTUAL_ENV']\n    sys.path.insert(0, project_base_dir)\n    activate_this = os.path.join(project_base_dir, 'bin/activate_this.py')\n    execfile(activate_this, dict(__file__=activate_this))\nEOF\n</code></pre>\n<h1>Django</h1>\n<p>The only true django tweak I make is before I open vim I'll export the\nDJANGO_SETTINGS_MODULE environment so that I get code completion for\ndjango modules as well:</p>\n<pre><code>export DJANGO_SETTINGS_MODULE=project.settings\n</code></pre>\n<h1>Random Tips</h1>\n<p>If you want to find a new color scheme just go to\n<a href=\"http://code.google.com/p/vimcolorschemetest/\">http://code.google.com/p/vimcolorschemetest/</a> to preview a large\nselection.</p>\n<p>John Anderson &#x3C;<a href=\"mailto:sontek@gmail.com\">sontek@gmail.com</a>> 2011</p>\n","category":"python\n","date":"2011-05-06T20:00:00-04:00","tags":"vim, python\n","title":"Turning Vim into a modern Python IDE"},{"id":["old","tips_and_tricks_for_the_python_interpreter"],"path":"old/tips_and_tricks_for_the_python_interpreter","contentHtml":"<p>I have seen a lot of people switch over to using ipython, bpython, etc\nto get auto-complete support without realizing that the standard\ninterpreter does have this functionality.</p>\n<p>To enable auto-complete support in the python interpreter you need to\ncreate a python startup file that enables readline support. A python\nstartup file is just a bunch of python code that gets executed at\nstartup of the interpreter. To do this you just setup PYTHONSTARTUP in\nyour ~/.bashrc and then create a ~/.pythonrc.py file:</p>\n<pre><code><span>#.bashrc</span>\nPYTHONSTARTUP=~/.pythonrc.py\nexport PYTHONSTARTUP\n\n<span>#.pythonrc.py</span>\n<span>try</span>:\n    <span>import</span> readline\n<span>except</span> ImportError:\n    <span>print</span>(<span>\"Module readline not available.\"</span>)\n<span>else</span>:\n    <span>import</span> rlcompleter\n    readline.parse_and_bind(<span>\"tab: complete\"</span>)</code></pre>\n<p>Now when you are in python you have tab completion on importing, calling\nmethods on a module, etc.</p>\n<pre><code><span>>>> </span><span>import</span> o\n<span>object</span>(  <span>oct</span>(     <span>open</span>(    <span>or</span>       <span>ord</span>(     os</code></pre>\n<p>I always end up using the pretty print module for viewing long lists and\nstrings in the interpreter so I prefer to just use it by default:</p>\n<pre><code><span># Enable Pretty Printing for stdout</span>\n<span>import</span> pprint\n<span>def</span> <span>my_displayhook</span>(<span>value</span>):\n    <span>if</span> value <span>is</span> <span>not</span> <span>None</span>:\n        <span>try</span>:\n            <span>import</span> __builtin__\n            __builtin__._ = value\n        <span>except</span> ImportError:\n            __builtins__._ = value\n\n        pprint.pprint(value)\n\nsys.displayhook = my_displayhook</code></pre>\n<p>It is also very useful to be able to load up your favorite editor to\nedit lines of code from the interpreter, you can do this by adding the\nfollowing into your ~/.pythonrc.py:</p>\n<pre><code><span>import</span> os\n<span>import</span> sys\n<span>from</span> code <span>import</span> InteractiveConsole\n<span>from</span> tempfile <span>import</span> mkstemp\n\nEDITOR = os.environ.get(<span>'EDITOR'</span>, <span>'vi'</span>)\nEDIT_CMD = <span>'\\e'</span>\n\n<span>class</span> <span>EditableBufferInteractiveConsole</span>(<span>InteractiveConsole</span>):\n    <span>def</span> <span>__init__</span>(<span>self, *args, **kwargs</span>):\n        self.last_buffer = [] <span># This holds the last executed statement</span>\n        InteractiveConsole.__init__(self, *args, **kwargs)\n\n    <span>def</span> <span>runsource</span>(<span>self, source, *args</span>):\n        self.last_buffer = [ source.encode(<span>'latin-1'</span>) ]\n        <span>return</span> InteractiveConsole.runsource(self, source, *args)\n\n    <span>def</span> <span>raw_input</span>(<span>self, *args</span>):\n        line = InteractiveConsole.raw_input(self, *args)\n        <span>if</span> line == EDIT_CMD:\n            fd, tmpfl = mkstemp(<span>'.py'</span>)\n            os.write(fd, <span>b'\\n'</span>.join(self.last_buffer))\n            os.close(fd)\n            os.system(<span>'%s %s'</span> % (EDITOR, tmpfl))\n            line = <span>open</span>(tmpfl).read()\n            os.unlink(tmpfl)\n            tmpfl = <span>''</span>\n            lines = line.split( <span>'\\n'</span> )\n            <span>for</span> i <span>in</span> <span>range</span>(<span>len</span>(lines) - <span>1</span>): self.push( lines[i] )\n            line = lines[-<span>1</span>]\n        <span>return</span> line\n\nc = EditableBufferInteractiveConsole(<span>locals</span>=<span>locals</span>())\nc.interact(banner=<span>''</span>)\n\n<span># Exit the Python shell on exiting the InteractiveConsole</span>\nsys.exit()</code></pre>\n<p>For Django developers when you load up the ./manage.py shell it is nice\nto have access to all your models and settings for testing:</p>\n<pre><code><span># If we're working with a Django project, set up the environment</span>\n<span>if</span> <span>'DJANGO_SETTINGS_MODULE'</span> <span>in</span> os.environ:\n    <span>from</span> django.db.models.loading <span>import</span> get_models\n    <span>from</span> django.test.client <span>import</span> Client\n    <span>from</span> django.test.utils <span>import</span> setup_test_environment, teardown_test_environment\n    <span>from</span> django.conf <span>import</span> settings <span>as</span> S\n\n    <span>class</span> <span>DjangoModels</span>(<span>object</span>):\n        <span>\"\"\"Loop through all the models in INSTALLED_APPS and import them.\"\"\"</span>\n        <span>def</span> <span>__init__</span>(<span>self</span>):\n            <span>for</span> m <span>in</span> get_models():\n                <span>setattr</span>(self, m.__name__, m)\n\n    A = DjangoModels()\n    C = Client()</code></pre>\n<p>After these tweaks the python interpreter is a lot more powerful and you\nreally lose the need for the more interactive shells like ipython and\nbpython. All of these settings work in both python2 and python3.</p>\n<p>If you want to see my complete ~/.pythonrc.py you can get it on\n<a href=\"https://github.com/sontek/dotfiles/blob/master/_pythonrc.py\">github</a></p>\n","category":"python\n","date":"2010-12-27T20:00:00-04:00","tags":"python\n","title":"Tips and Tricks for the Python Interpreter"},{"id":["old","caesar_cipher_in_python"],"path":"old/caesar_cipher_in_python","contentHtml":"<p>I'm currently teaching my wife to code and one of the problems that we\nworked on to teach her some fundamental programming concepts was\nre-implementing the caesar cipher in python. It was fun not only to code\nbut to also start sending each other \"secret\" messages!</p>\n<p>The caesar cipher is a rather simple encoding, you just shift the\nalphabet a certain amount of characters. For example, if you are using a\nshift of 2:</p>\n<pre><code>a => c\nb => d\ny => a\nz => b\n</code></pre>\n<p>Using this as an interview type question would provide a few interesting\nproblems and give you a good perspective on how good a developers\nproblem solving skills are and how knowledgeable they are in the\nlanguage of their choice.</p>\n<p>The first issue is to handle the beginning and end of the alphabet, if\nyou are encoding 'z' then you will have to start your shift on a. The\nsecond problem is to only encode letters since there was no ascii table\nto define in what order characters are shifted back in those times.</p>\n<p>Without using too much of the built in python niceties you could do\nsomething similar to this:</p>\n<pre><code><span>#!/usr/bin/python</span>\n<span>def</span> <span>decode_shift_letter</span>(<span>current_ord, start, end, shift</span>):\n    <span>if</span> current_ord - shift &#x3C; start:\n        new_ord = (current_ord + <span>26</span>) - shift\n        <span>return</span> <span>chr</span>(new_ord)\n    <span>else</span>:\n        <span>return</span> <span>chr</span>(current_ord-shift)\n\n<span>def</span> <span>encode_shift_letter</span>(<span>current_ord, start, end, shift</span>):\n    <span>if</span> current_ord + shift > end:\n        new_ord = (current_ord - <span>26</span>) + shift\n        <span>return</span> <span>chr</span>(new_ord)\n    <span>else</span>:\n        <span>return</span> <span>chr</span>(current_ord+shift)\n\n<span>def</span> <span>decode</span>(<span><span>input</span>, shift</span>):\n    <span>return</span> modify_input(<span>input</span>, shift, decode_shift_letter)\n\n<span>def</span> <span>encode</span>(<span><span>input</span>, shift</span>):\n    <span>return</span> modify_input(<span>input</span>, shift, encode_shift_letter)\n\n<span>def</span> <span>modify_input</span>(<span><span>input</span>, shift, shift_letter</span>):\n    new_sentence = <span>''</span>\n\n    <span>for</span> letter <span>in</span> <span>input</span>:\n        <span># we only encode letters, random characters like +!%$ are not encoded.</span>\n        <span># Lower and Capital letters are not stored near each other on the</span>\n        <span># ascii table</span>\n        lower_start = <span>ord</span>(<span>'a'</span>)\n        lower_end = <span>ord</span>(<span>'z'</span>)\n        upper_start = <span>ord</span>(<span>'A'</span>)\n        upper_end = <span>ord</span>(<span>'Z'</span>)\n        current_ord = <span>ord</span>(letter)\n\n        <span>if</span> current_ord >= lower_start <span>and</span> current_ord &#x3C;= lower_end:\n            new_sentence += shift_letter(current_ord, lower_start, lower_end, shift)\n        <span>elif</span> current_ord >= upper_start <span>and</span> current_ord &#x3C;= upper_end:\n            new_sentence += shift_letter(current_ord, upper_start, upper_end, shift)\n        <span>else</span>:\n            new_sentence += letter\n\n    <span>return</span> new_sentence\n\n\n<span>def</span> <span>get_shift</span>():\n    <span>try</span>:\n        shift = <span>int</span>(raw_input(<span>'What shift would you like to use?\\n'</span>))\n    <span>except</span> ValueError:\n        <span>print</span> <span>'Shift must be a number'</span>\n        shift = get_shift()\n\n    <span>if</span> <span>not</span> (shift > <span>0</span> <span>and</span> shift &#x3C;= <span>25</span>):\n        <span>print</span> <span>'Shift must be between 1 and 25'</span>\n        shift = get_shift()\n\n    <span>return</span> shift\n\n<span>def</span> <span>main</span>():\n    <span>try</span>:\n        task = <span>int</span>(raw_input(<span>'1) Encode \\n'</span>+ \\\n                             <span>'2) Decode \\n'</span>))\n    <span>except</span> ValueError:\n        <span>print</span> <span>'Invalid task, try again!'</span>\n        main()\n\n    shift = get_shift()\n    <span>input</span> = raw_input(<span>'What message would you like to %s\\n'</span> % (<span>'Encode'</span> <span>if</span> task == <span>1</span> <span>else</span> <span>'Decode'</span>))\n\n    <span>if</span> task == <span>1</span>:\n        <span>print</span> encode(<span>input</span>, shift)\n    <span>elif</span> task == <span>2</span>:\n        <span>print</span> decode(<span>input</span>, shift)\n\n<span>if</span> __name__ == <span>'__main__'</span>:\n    main()</code></pre>\n<p>This would prove that you are a decent problem solver and have enough of\nthe language to get things done but if you want to prove you have\nmastered the python language you might take advantage of some slicing\nand some methods out of the string module and change your code to look\nsomething like:</p>\n<pre><code><span>from</span> string <span>import</span> letters, maketrans\n\n<span>def</span> <span>decode</span>(<span><span>input</span>, shift</span>):\n    <span>return</span> modify_input(<span>input</span>, -shift)\n\n<span>def</span> <span>encode</span>(<span><span>input</span>, shift</span>):\n    <span>return</span> modify_input(<span>input</span>, shift)\n\n<span>def</span> <span>modify_input</span>(<span><span>input</span>, shift</span>):\n    trans = maketrans(letters, letters[shift:] + letters[:shift])\n    <span>return</span> <span>input</span>.translate(trans)</code></pre>\n<p>Do get more information on string.letters and string.maketrans you can\nvisit their documentation\n[here](<a href=\"http://docs.python.org/library/string.html\">http://docs.python.org/library/string.html</a>)</p>\n","category":"none\n","date":"2010-11-14T20:00:00-04:00","tags":"python, interviews\n","title":"Caesar Cipher in Python"},{"id":["old","convert_a_string_to_an_integer_in_python"],"path":"old/convert_a_string_to_an_integer_in_python","contentHtml":"<p>A fun interview question some developers like to ask is to have you\nconvert ascii characters to an integer without using built in methods\nlike string.atoi or int().</p>\n<p>So using python the obvious ways to convert a string to an integer are\nthese:</p>\n<pre><code><span>>>> </span><span>int</span>(<span>'1234'</span>)\n<span>1234</span>\n<span>>>> </span><span>import</span> string\n<span>>>> </span>string.atoi(<span>'1234'</span>)\n<span>1234</span></code></pre>\n<p>The interesting thing here is finding out where on the ascii character\ntable the number is. Luckily python has this already built in with the\nord method:</p>\n<pre><code><span>>>> </span><span>help</span>(<span>ord</span>)\n\n<span>ord</span>(...)\n    <span>ord</span>(c) -> integer\n\n    Return the integer ordinal of a one-character string.\n\n<span>>>> </span><span>ord</span>(<span>'1'</span>)\n<span>49</span>\n<span>>>> </span><span>ord</span>(<span>'2'</span>)\n<span>50</span></code></pre>\n<p>You can see that the numbers are grouped together on the ascii table, so\nyou just have to grab '0' as the base and subtract the rest:</p>\n<pre><code><span>>>> </span><span>ord</span>(<span>'1'</span>)-<span>ord</span>(<span>'0'</span>)\n<span>1</span></code></pre>\n<p>So if we have the string '1234', we can get each of the individual\nnumbers by looping over it:</p>\n<pre><code><span>>>> </span>num_string = <span>'1234'</span>\n<span>>>> </span>num_list = []\n<span>>>> </span>base = <span>ord</span>(<span>'0'</span>)\n<span>>>> </span><span>for</span> num <span>in</span> num_string:\n<span>... </span>  num_list.append(<span>ord</span>(num) - base)\n...\n<span>>>> </span><span>print</span> num_list\n[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>]</code></pre>\n<p>but now how to we combine all these together to get 1234? You can't\njust add them up because you'll just get 1+2+3+4 = 10.</p>\n<p>So, we have to get 1000 + 200 + 30 + 4, which is a simple problem to\nsolve. Its just number times 10 to the nth power, so the final solution\nis:</p>\n<pre><code>num = <span>'1234'</span>\nnew_num = <span>0</span>\nbase = <span>ord</span>(<span>'0'</span>)\n\n<span>for</span> i,n <span>in</span> <span>enumerate</span>(<span>reversed</span>(num)):\n      new_num += (<span>ord</span>(n) - base) * (<span>10</span>**i)\n\n<span>print</span> new_num</code></pre>\n<p>This code is a little verbose though, lets make it a dirty nasty one\nliner!</p>\n<pre><code><span>>>> </span><span>sum</span>([(<span>ord</span>(n)-<span>ord</span>(<span>'0'</span>)) * (<span>10</span> ** i) <span>for</span> i,n <span>in</span> <span>enumerate</span>(<span>reversed</span>(<span>'1234'</span>))])\n<span>1234</span></code></pre>\n","category":"python\n","date":"2010-10-27T20:00:00-04:00","tags":"python, interviews\n","title":"Convert a string to an integer in Python"}]},"__N_SSG":true}