<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Automate project workflows with the command runner Just!</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/4e645f88d9d5f47b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4e645f88d9d5f47b.css" data-n-g=""/><link rel="preload" href="/_next/static/css/95e79f6f6f52c645.css" as="style"/><link rel="stylesheet" href="/_next/static/css/95e79f6f6f52c645.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-d7b038a63b619762.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-2a9c662ddd7329fb.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2e2b8b955a26d1f2.js" defer=""></script><script src="/_next/static/chunks/664-41844e7ff48658f9.js" defer=""></script><script src="/_next/static/chunks/494-fa03e5491fc3b3a9.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5B...id%5D-62742065773be53f.js" defer=""></script><script src="/_next/static/Qa1nVvJYCgWICCa_oRNHH/_buildManifest.js" defer=""></script><script src="/_next/static/Qa1nVvJYCgWICCa_oRNHH/_ssgManifest.js" defer=""></script><script src="/_next/static/Qa1nVvJYCgWICCa_oRNHH/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div><div class="grid"><div class="col"><header id="banner" class="body"><h1><a href="/">sontek.net</a></h1></header></div><div class="col menu"><nav><ul><li><a href="/">Home</a></li><li><a href="/blog">Blog</a></li><li><a href="/resume">Resume</a></li><li><a href="/about">About</a></li></ul></nav></div></div><div class="container"><article class="blog_article__NoEy4"><h1 class="util_headingXl__knZ_h">Automate project workflows with the command runner Just!</h1><div class="util_lightText__xcqUE"><time dateTime="2022-02-25T20:00:00-04:00">February 25, 2022</time></div><div><p>I believe every project should have a CLI built around the standard workflows of developing
on the project.  Things like:</p>
<ul>
<li>Install dependencies</li>
<li>Run tests</li>
<li>Run linter and formatters</li>
<li>Build project</li>
<li>Start / Stop the docker environment</li>
</ul>
<p>The reason I think this is important is because it makes a nice consistent and discoverable
entrypoint for understanding how you should work in the project.   If you only provide the
instructions in the <code>README</code> then you have to remember to update those docs every time you
add a new command.  Those docs aren't easily testable either.</p>
<p>Most of my career the command runner of choice for my projects as been <code>GNU Make</code> but it was
definitely the wrong tool for the job.  It is a build tool that I bent into shape to work
as a command runner for me.   These days I use the tool <a href="https://github.com/casey/just">just</a>.</p>
<h2>Intro to just</h2>
<p><a href="https://github.com/casey/just">Just</a> is a modern command runner with a similar syntax to <code>make</code>
that provides a nice way for building out your project CLI!  You create a file named <code>justfile</code>
at the root of your project and then the basic syntax is:</p>
<pre><code class="hljs language-make"><span class="hljs-section">help:</span>
  @just --list

<span class="hljs-comment"># My first command</span>
<span class="hljs-section">first:</span>
  echo <span class="hljs-string">"Any commands you want to run go here!"</span>
</code></pre>
<p>The first <code>help</code> line defines a command "help" for your CLI and it lists out all the other available
commans.  I always put this line first because <code>just</code> runs the first command in the file if a specific
command isn't requested.  The output of this file looks like this:</p>
<pre><code class="hljs language-bash">❯ just
Available recipes:
    first <span class="hljs-comment"># My first command</span>
    <span class="hljs-built_in">help</span>
</code></pre>
<p>Having help automatically generated is fantastic!  Its also really helpful that it adds the comment
to the command so that each command is self-documenting.  If you run the <code>first</code> command you'll notice
it also has a feature where it prints out the commands being ran so the user knows exactly what is
happening:</p>
<pre><code class="hljs language-bash">❯ just first
<span class="hljs-built_in">echo</span> <span class="hljs-string">"Any commands you want to run go here!"</span>
Any commands you want to run go here!
</code></pre>
<p>This doesn't always make sense though, so you can quickly remove that behavior by putting an <code>@</code> in front
of any of the commands, like I did for the <code>help</code> command above.  You can also declare dependencies if
you have re-usable parts of your workflow that many of your commands need.</p>
<p>For example, you might want to check versions of things like <code>node</code> and <code>python</code> before running the install
of their dependencies. So you could do something like:</p>
<pre><code class="hljs language-make"><span class="hljs-section">help:</span>
  @just --list

node_version := <span class="hljs-string">"v17.6.0"</span>

<span class="hljs-comment"># Verify system dependencies</span>
<span class="hljs-section">check-dependencies:</span>
  @if [ ! <span class="hljs-string">"$(node --version)"</span> = {{ node_version }} ]; \
  then \
    echo <span class="hljs-string">"Missing node version: {{ node_version }}"</span>; \
    exit 1; \
  fi

<span class="hljs-comment"># Install frontend</span>
<span class="hljs-section">install: check-dependencies</span>
  @echo <span class="hljs-string">"yarn install"</span>
</code></pre>
<p>which ends up with a CLI that looks like this:</p>
<pre><code class="hljs language-bash">❯ just
Available recipes:
    check-dependencies <span class="hljs-comment"># Verify system dependencies</span>
    <span class="hljs-built_in">help</span>
    install            <span class="hljs-comment"># Install frontend</span>

❯ just install
Missing node version: v17.6.0
error: Recipe `check-dependencies` failed on line 12 with <span class="hljs-built_in">exit</span> code 1
</code></pre>
<p>This opens up a lot of possibilities! In the above <code>justfile</code> you'll notice I'm using a multi-line
command but I have <code>\</code> at the end of each line.  This is because <code>just</code> by default is going to run
each new line in their own shell.   So this just makes all those lines run in the same shell.</p>
<p>You do not have to use this syntax though.  Just is <code>polyglot</code> and can run commands from any language
you would like.</p>
<h3>Polyglot</h3>
<p>If you want to use a bash script as one of your commands, you can do so by adding a shebang at the top:</p>
<pre><code class="hljs language-make"><span class="hljs-section">check-dependencies:</span>
  <span class="hljs-comment">#!/usr/bin/env bash</span>
  set -euxo pipefail
  if [ ! <span class="hljs-string">"$(node --version)"</span> = {{ node_version }} ];
  then
    echo <span class="hljs-string">"Missing node version: {{ node_version }}"</span>
    exit 1
  fi
</code></pre>
<p>Now the entire command is using a bash script to execute! This gets really interesting if you want to start
using things like python, so if you'd like to change the dependency checker above to python:</p>
<pre><code class="hljs language-python">check-dependencies:
  <span class="hljs-comment">#!/usr/bin/env python3</span>
  <span class="hljs-keyword">import</span> subprocess
  result = subprocess.run(
    [<span class="hljs-string">'node'</span>, <span class="hljs-string">'--version'</span>],
    stdout=subprocess.PIPE
  )
  <span class="hljs-keyword">if</span> result != <span class="hljs-string">"{{ node_version }}"</span>:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"Missing node version: {{ node_version }}"</span>)
    exit(<span class="hljs-number">1</span>)
</code></pre>
<p>You can even tell <code>just</code> that you want to use a specific language for all commands!</p>
<pre><code class="hljs language-arduino">set shell := [<span class="hljs-string">"python3"</span>, <span class="hljs-string">"-c"</span>]
</code></pre>
<p>This not only affects the commands you have in your recipe but also anything inside
backticks!  So something like:</p>
<pre><code class="hljs language-make">`print(<span class="hljs-string">"Rust is the best programming language"</span>)`
</code></pre>
<p>It would run through python instead of the shell.</p>
<h3>Enviornment Files</h3>
<p>One of the other modern things <code>just</code> adds to your workflow is the ability to utilize dotenv
files.  So for example if you want to define which port you launch your http server on, you can
create a file called <code>.env</code>:</p>
<pre><code class="hljs language-bash">WEBSERVER_PORT=9000
</code></pre>
<p>and then utilize it in your <code>justfile</code>:</p>
<pre><code class="hljs language-make">set dotenv-load

<span class="hljs-section">http:</span>
  @echo <span class="hljs-string">"Starting webserver in current directory"</span>
  python3 -m http.server $WEBSERVER_PORT
</code></pre>
<p>When you run <code>just http</code> it'll launch the http server on port 9000.  One important line
in this file is <code>set dotenv-load</code>, it will not load the <code>.env</code> file without you telling it to.</p>
<h2>Don't use language specific scripts!</h2>
<p>I'n not a fan of language specific command runners like <code>package.json</code> in the node community.</p>
<p>It always frustrates me when I start working on a project that heavily uses <code>scripts</code> in their
package.json instead of using a real command runner. <code>json</code> is not a great format for writing
discoverable CLI commands. For example if you wanted to write a <code>next.js</code> build script:</p>
<pre><code class="hljs language-json">    <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"predeploy"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"yarn build &#x26;&#x26; yarn export &#x26;&#x26; touch dist/.nojekyll &#x26;&#x26; echo sontek.net > dist/CNAME"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"deploy"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"gh-pages -d dist -t true"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"next build"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"export"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"next export -o dist/"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
</code></pre>
<p>Combining all those commands is really messy and not easily understandable through <code>yarn run</code>:</p>
<pre><code class="hljs language-bash">❯ yarn run
yarn run v1.22.17
info Commands available from binary scripts: autoprefixer, browserslist, css-blank-pseudo, css-has-pseudo, css-prefers-color-scheme, cssesc, esparse, esvalidate, extract-zip, gh-pages, gh-pages-clean, js-yaml, loose-envify, nanoid, next, prettier, resolve, rimraf, semver, svgo, uvu
info Project commands
   - build
      next build
   - deploy
      gh-pages -d dist -t <span class="hljs-literal">true</span>
   - <span class="hljs-built_in">export</span>
      next <span class="hljs-built_in">export</span> -o dist/
   - predeploy
      yarn build &#x26;&#x26; yarn <span class="hljs-built_in">export</span> &#x26;&#x26; <span class="hljs-built_in">touch</span> dist/.nojekyll &#x26;&#x26; <span class="hljs-built_in">echo</span> sontek.net > dist/CNAME
</code></pre>
<p>I'd much rather have this:</p>
<pre><code class="hljs language-bash">❯ just
Available recipes:
    build       <span class="hljs-comment"># Build frontend assets</span>
    deploy      <span class="hljs-comment"># Deploy assets to cloudfront</span>
    <span class="hljs-built_in">export</span>      <span class="hljs-comment"># Export to static assets (no SSR)</span>
</code></pre>
<h2>Conclusion</h2>
<p><a href="https://github.com/casey/just">Just</a> is a wonderful tool for building project specific CLIs without much effort. It is
a great replacement for <code>Make</code> if you are using it as a command runner and it has most of the features you'd need.</p>
<p>I recommend adding a <code>justfile</code> to your projects today! If you'd like to see a real world example of how to use <code>just</code>,
you can check out the one I use to maintain my <a href="https://github.com/sontek/homies/blob/master/justfile">home directory</a>!</p></div></article></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":["2022","intro_to_just"],"path":"2022/intro_to_just","contentHtml":"\u003cp\u003eI believe every project should have a CLI built around the standard workflows of developing\non the project.  Things like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eInstall dependencies\u003c/li\u003e\n\u003cli\u003eRun tests\u003c/li\u003e\n\u003cli\u003eRun linter and formatters\u003c/li\u003e\n\u003cli\u003eBuild project\u003c/li\u003e\n\u003cli\u003eStart / Stop the docker environment\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe reason I think this is important is because it makes a nice consistent and discoverable\nentrypoint for understanding how you should work in the project.   If you only provide the\ninstructions in the \u003ccode\u003eREADME\u003c/code\u003e then you have to remember to update those docs every time you\nadd a new command.  Those docs aren't easily testable either.\u003c/p\u003e\n\u003cp\u003eMost of my career the command runner of choice for my projects as been \u003ccode\u003eGNU Make\u003c/code\u003e but it was\ndefinitely the wrong tool for the job.  It is a build tool that I bent into shape to work\nas a command runner for me.   These days I use the tool \u003ca href=\"https://github.com/casey/just\"\u003ejust\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eIntro to just\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/casey/just\"\u003eJust\u003c/a\u003e is a modern command runner with a similar syntax to \u003ccode\u003emake\u003c/code\u003e\nthat provides a nice way for building out your project CLI!  You create a file named \u003ccode\u003ejustfile\u003c/code\u003e\nat the root of your project and then the basic syntax is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-make\"\u003e\u003cspan class=\"hljs-section\"\u003ehelp:\u003c/span\u003e\n  @just --list\n\n\u003cspan class=\"hljs-comment\"\u003e# My first command\u003c/span\u003e\n\u003cspan class=\"hljs-section\"\u003efirst:\u003c/span\u003e\n  echo \u003cspan class=\"hljs-string\"\u003e\"Any commands you want to run go here!\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe first \u003ccode\u003ehelp\u003c/code\u003e line defines a command \"help\" for your CLI and it lists out all the other available\ncommans.  I always put this line first because \u003ccode\u003ejust\u003c/code\u003e runs the first command in the file if a specific\ncommand isn't requested.  The output of this file looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e❯ just\nAvailable recipes:\n    first \u003cspan class=\"hljs-comment\"\u003e# My first command\u003c/span\u003e\n    \u003cspan class=\"hljs-built_in\"\u003ehelp\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHaving help automatically generated is fantastic!  Its also really helpful that it adds the comment\nto the command so that each command is self-documenting.  If you run the \u003ccode\u003efirst\u003c/code\u003e command you'll notice\nit also has a feature where it prints out the commands being ran so the user knows exactly what is\nhappening:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e❯ just first\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Any commands you want to run go here!\"\u003c/span\u003e\nAny commands you want to run go here!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis doesn't always make sense though, so you can quickly remove that behavior by putting an \u003ccode\u003e@\u003c/code\u003e in front\nof any of the commands, like I did for the \u003ccode\u003ehelp\u003c/code\u003e command above.  You can also declare dependencies if\nyou have re-usable parts of your workflow that many of your commands need.\u003c/p\u003e\n\u003cp\u003eFor example, you might want to check versions of things like \u003ccode\u003enode\u003c/code\u003e and \u003ccode\u003epython\u003c/code\u003e before running the install\nof their dependencies. So you could do something like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-make\"\u003e\u003cspan class=\"hljs-section\"\u003ehelp:\u003c/span\u003e\n  @just --list\n\nnode_version := \u003cspan class=\"hljs-string\"\u003e\"v17.6.0\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# Verify system dependencies\u003c/span\u003e\n\u003cspan class=\"hljs-section\"\u003echeck-dependencies:\u003c/span\u003e\n  @if [ ! \u003cspan class=\"hljs-string\"\u003e\"$(node --version)\"\u003c/span\u003e = {{ node_version }} ]; \\\n  then \\\n    echo \u003cspan class=\"hljs-string\"\u003e\"Missing node version: {{ node_version }}\"\u003c/span\u003e; \\\n    exit 1; \\\n  fi\n\n\u003cspan class=\"hljs-comment\"\u003e# Install frontend\u003c/span\u003e\n\u003cspan class=\"hljs-section\"\u003einstall: check-dependencies\u003c/span\u003e\n  @echo \u003cspan class=\"hljs-string\"\u003e\"yarn install\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhich ends up with a CLI that looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e❯ just\nAvailable recipes:\n    check-dependencies \u003cspan class=\"hljs-comment\"\u003e# Verify system dependencies\u003c/span\u003e\n    \u003cspan class=\"hljs-built_in\"\u003ehelp\u003c/span\u003e\n    install            \u003cspan class=\"hljs-comment\"\u003e# Install frontend\u003c/span\u003e\n\n❯ just install\nMissing node version: v17.6.0\nerror: Recipe `check-dependencies` failed on line 12 with \u003cspan class=\"hljs-built_in\"\u003eexit\u003c/span\u003e code 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis opens up a lot of possibilities! In the above \u003ccode\u003ejustfile\u003c/code\u003e you'll notice I'm using a multi-line\ncommand but I have \u003ccode\u003e\\\u003c/code\u003e at the end of each line.  This is because \u003ccode\u003ejust\u003c/code\u003e by default is going to run\neach new line in their own shell.   So this just makes all those lines run in the same shell.\u003c/p\u003e\n\u003cp\u003eYou do not have to use this syntax though.  Just is \u003ccode\u003epolyglot\u003c/code\u003e and can run commands from any language\nyou would like.\u003c/p\u003e\n\u003ch3\u003ePolyglot\u003c/h3\u003e\n\u003cp\u003eIf you want to use a bash script as one of your commands, you can do so by adding a shebang at the top:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-make\"\u003e\u003cspan class=\"hljs-section\"\u003echeck-dependencies:\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e#!/usr/bin/env bash\u003c/span\u003e\n  set -euxo pipefail\n  if [ ! \u003cspan class=\"hljs-string\"\u003e\"$(node --version)\"\u003c/span\u003e = {{ node_version }} ];\n  then\n    echo \u003cspan class=\"hljs-string\"\u003e\"Missing node version: {{ node_version }}\"\u003c/span\u003e\n    exit 1\n  fi\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow the entire command is using a bash script to execute! This gets really interesting if you want to start\nusing things like python, so if you'd like to change the dependency checker above to python:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003echeck-dependencies:\n  \u003cspan class=\"hljs-comment\"\u003e#!/usr/bin/env python3\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e subprocess\n  result = subprocess.run(\n    [\u003cspan class=\"hljs-string\"\u003e'node'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'--version'\u003c/span\u003e],\n    stdout=subprocess.PIPE\n  )\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e result != \u003cspan class=\"hljs-string\"\u003e\"{{ node_version }}\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"Missing node version: {{ node_version }}\"\u003c/span\u003e)\n    exit(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can even tell \u003ccode\u003ejust\u003c/code\u003e that you want to use a specific language for all commands!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-arduino\"\u003eset shell := [\u003cspan class=\"hljs-string\"\u003e\"python3\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"-c\"\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis not only affects the commands you have in your recipe but also anything inside\nbackticks!  So something like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-make\"\u003e`print(\u003cspan class=\"hljs-string\"\u003e\"Rust is the best programming language\"\u003c/span\u003e)`\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt would run through python instead of the shell.\u003c/p\u003e\n\u003ch3\u003eEnviornment Files\u003c/h3\u003e\n\u003cp\u003eOne of the other modern things \u003ccode\u003ejust\u003c/code\u003e adds to your workflow is the ability to utilize dotenv\nfiles.  So for example if you want to define which port you launch your http server on, you can\ncreate a file called \u003ccode\u003e.env\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eWEBSERVER_PORT=9000\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand then utilize it in your \u003ccode\u003ejustfile\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-make\"\u003eset dotenv-load\n\n\u003cspan class=\"hljs-section\"\u003ehttp:\u003c/span\u003e\n  @echo \u003cspan class=\"hljs-string\"\u003e\"Starting webserver in current directory\"\u003c/span\u003e\n  python3 -m http.server $WEBSERVER_PORT\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen you run \u003ccode\u003ejust http\u003c/code\u003e it'll launch the http server on port 9000.  One important line\nin this file is \u003ccode\u003eset dotenv-load\u003c/code\u003e, it will not load the \u003ccode\u003e.env\u003c/code\u003e file without you telling it to.\u003c/p\u003e\n\u003ch2\u003eDon't use language specific scripts!\u003c/h2\u003e\n\u003cp\u003eI'n not a fan of language specific command runners like \u003ccode\u003epackage.json\u003c/code\u003e in the node community.\u003c/p\u003e\n\u003cp\u003eIt always frustrates me when I start working on a project that heavily uses \u003ccode\u003escripts\u003c/code\u003e in their\npackage.json instead of using a real command runner. \u003ccode\u003ejson\u003c/code\u003e is not a great format for writing\ndiscoverable CLI commands. For example if you wanted to write a \u003ccode\u003enext.js\u003c/code\u003e build script:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e    \u003cspan class=\"hljs-attr\"\u003e\"scripts\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003e\"predeploy\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"yarn build \u0026#x26;\u0026#x26; yarn export \u0026#x26;\u0026#x26; touch dist/.nojekyll \u0026#x26;\u0026#x26; echo sontek.net \u003e dist/CNAME\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003e\"deploy\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"gh-pages -d dist -t true\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003e\"build\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next build\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003e\"export\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"next export -o dist/\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCombining all those commands is really messy and not easily understandable through \u003ccode\u003eyarn run\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e❯ yarn run\nyarn run v1.22.17\ninfo Commands available from binary scripts: autoprefixer, browserslist, css-blank-pseudo, css-has-pseudo, css-prefers-color-scheme, cssesc, esparse, esvalidate, extract-zip, gh-pages, gh-pages-clean, js-yaml, loose-envify, nanoid, next, prettier, resolve, rimraf, semver, svgo, uvu\ninfo Project commands\n   - build\n      next build\n   - deploy\n      gh-pages -d dist -t \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n   - \u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e\n      next \u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e -o dist/\n   - predeploy\n      yarn build \u0026#x26;\u0026#x26; yarn \u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-built_in\"\u003etouch\u003c/span\u003e dist/.nojekyll \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e sontek.net \u003e dist/CNAME\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI'd much rather have this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e❯ just\nAvailable recipes:\n    build       \u003cspan class=\"hljs-comment\"\u003e# Build frontend assets\u003c/span\u003e\n    deploy      \u003cspan class=\"hljs-comment\"\u003e# Deploy assets to cloudfront\u003c/span\u003e\n    \u003cspan class=\"hljs-built_in\"\u003eexport\u003c/span\u003e      \u003cspan class=\"hljs-comment\"\u003e# Export to static assets (no SSR)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/casey/just\"\u003eJust\u003c/a\u003e is a wonderful tool for building project specific CLIs without much effort. It is\na great replacement for \u003ccode\u003eMake\u003c/code\u003e if you are using it as a command runner and it has most of the features you'd need.\u003c/p\u003e\n\u003cp\u003eI recommend adding a \u003ccode\u003ejustfile\u003c/code\u003e to your projects today! If you'd like to see a real world example of how to use \u003ccode\u003ejust\u003c/code\u003e,\nyou can check out the one I use to maintain my \u003ca href=\"https://github.com/sontek/homies/blob/master/justfile\"\u003ehome directory\u003c/a\u003e!\u003c/p\u003e","category":"Development","date":"2022-02-25T20:00:00-04:00","tags":["Linux"],"title":"Automate project workflows with the command runner Just!"}},"__N_SSG":true},"page":"/blog/[...id]","query":{"id":["2022","intro_to_just"]},"buildId":"Qa1nVvJYCgWICCa_oRNHH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>