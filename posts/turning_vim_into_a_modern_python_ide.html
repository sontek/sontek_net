<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Turning Vim into a modern Python IDE</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/6060a664e90c5fb4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6060a664e90c5fb4.css" data-n-g=""/><link rel="preload" href="/_next/static/css/421ede9ab5a915a5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/421ede9ab5a915a5.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-529e237f188dc66d.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4777b1b835b905e6.js" defer=""></script><script src="/_next/static/chunks/247-d3d7ac0b996191c6.js" defer=""></script><script src="/_next/static/chunks/771-27d3774815323288.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-82dab2af2ec90eff.js" defer=""></script><script src="/_next/static/5XCxPLpqOzpyhJfzxeJqg/_buildManifest.js" defer=""></script><script src="/_next/static/5XCxPLpqOzpyhJfzxeJqg/_ssgManifest.js" defer=""></script><script src="/_next/static/5XCxPLpqOzpyhJfzxeJqg/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div><div class="grid"><div class="col"><header id="banner" class="body"><h1><a href="/">sontek.net</a></h1></header></div><div class="col menu"><nav><ul><li><a href="/">Home</a></li><li><a href="/blog">Blog</a></li><li><a href="/resume">Resume</a></li><li><a href="/about">About</a></li></ul></nav></div></div><div class="container"><article><h1 class="util_headingXl__38r1h">Turning Vim into a modern Python IDE</h1><div class="util_lightText__1ajZN"><time dateTime="2011-05-06T20:00:00-04:00">May 6, 2011</time></div><div><p>::: {.contents}
:::</p>
<p>TL;DR:</p>
<pre><code>$ git clone https://github.com/sontek/dotfiles.git
$ cd dotfiles
$ ./install.sh vim
</code></pre>
<h1>Intro</h1>
<p>Back in 2008, I wrote the article <a href="http://sontek.net/python-with-a-modular-ide-vim">Python with a modular IDE
(Vim)</a>. Years later, I
have people e-mailing me and commenting daily asking for more
information, even though most of the information in it is outdated. Here
is the modern way to work with Python and Vim to achieve the perfect
environment.</p>
<p>Because one of the most important parts about a development environment
is the ability to easily reproduce across machines, we are going to
store our vim configuration in git:</p>
<pre><code>$ mkdir ~/.vim/
$ mkdir ~/.vim/{autoload,bundle}
$ cd ~/.vim/
$ git init
</code></pre>
<p>The purpose of the autoload directory is to automatically load the vim
plugin <a href="https://github.com/tpope/vim-pathogen">Pathogen</a>, which we'll
then use to load all other plugins that are located in the bundle
directory. So download pathogen and put it in your autoload folder.</p>
<p>You'll need to add the following to your ~/.vimrc so that pathogen
will be loaded properly. Filetype detection must be off when you run the
commands so its best to execute them first:</p>
<pre><code>filetype off
call pathogen#runtime_append_all_bundles()
call pathogen#helptags()
</code></pre>
<p>Now lets add all of the vim plugins we plan on using as submodules to
our git repository:</p>
<pre><code>git submodule add http://github.com/tpope/vim-fugitive.git bundle/fugitive
git submodule add https://github.com/msanders/snipmate.vim.git bundle/snipmate
git submodule add https://github.com/tpope/vim-surround.git bundle/surround
git submodule add https://github.com/tpope/vim-git.git bundle/git
git submodule add https://github.com/ervandew/supertab.git bundle/supertab
git submodule add https://github.com/sontek/minibufexpl.vim.git bundle/minibufexpl
git submodule add https://github.com/wincent/Command-T.git bundle/command-t
git submodule add https://github.com/mitechie/pyflakes-pathogen.git
git submodule add https://github.com/mileszs/ack.vim.git bundle/ack
git submodule add https://github.com/sjl/gundo.vim.git bundle/gundo
git submodule add https://github.com/fs111/pydoc.vim.git bundle/pydoc
git submodule add https://github.com/vim-scripts/pep8.git bundle/pep8
git submodule add https://github.com/alfredodeza/pytest.vim.git bundle/py.test
git submodule add https://github.com/reinh/vim-makegreen bundle/makegreen
git submodule add https://github.com/vim-scripts/TaskList.vim.git bundle/tasklist
git submodule add https://github.com/vim-scripts/The-NERD-tree.git bundle/nerdtree
git submodule add https://github.com/sontek/rope-vim.git bundle/ropevim
git submodule init
git submodule update
git submodule foreach git submodule init
git submodule foreach git submodule update
</code></pre>
<p>Thats it! Now that we've got our vim configuration in git!</p>
<p>Now lets look at how to use each of these plugins to improve the power
of vim:</p>
<h1>Basic Editing and Debugging</h1>
<h2>Code Folding</h2>
<p>Lets first enable code folding. This makes it a lot easier to organize
your code and hide portions that you aren't interested in working on.
This is quite easy for Python, since whitespace is required.</p>
<p>In your ~/.vimrc just add:</p>
<pre><code>set foldmethod=indent
set foldlevel=99
</code></pre>
<p>Then you will be able to be inside a method and type 'za' to open and
close a fold.</p>
<h2>Window Splits</h2>
<p>Sometimes code folding isn't enough; you may need to start opening up
multiple windows and working on multiple files at once or different
locations within the same file. To do this in vim, you can use these
shortcuts:</p>
<pre><code>Vertical Split : Ctrl+w + v
Horizontal Split: Ctrl+w + s
Close current windows: Ctrl+w + q
</code></pre>
<p>I also like to bind Ctrl+&#x3C;movement> keys to move around the windows,
instead of using Ctrl+w + &#x3C;movement>:</p>
<pre><code>map &#x3C;c-j> &#x3C;c-w>j
map &#x3C;c-k> &#x3C;c-w>k
map &#x3C;c-l> &#x3C;c-w>l
map &#x3C;c-h> &#x3C;c-w>h
</code></pre>
<p><img src="http://i.imgur.com/krj0l.png" alt="image"></p>
<h2>Snippets</h2>
<p>The next tweak that really speeds up development is using snipmate.
We've already included it in our bundle/ folder so its already enabled.
Try opening up a python file and typing 'def&#x3C;tab>'. It should stub
out a method definition for you and allow you to tab through and fill
out the arguments, doc string, etc.</p>
<p>I also like to create my own snippets folder to put in some custom
snippets:</p>
<pre><code>$ mkdir ~/.vim/snippets
$ vim ~/.vim/snippets/python.snippets
</code></pre>
<p>Put this in the file:</p>
<pre><code>snippet pdb
    import pdb; pdb.set_trace()
</code></pre>
<p>Now you can type pdb&#x3C;tab> and it'll insert your breakpoint!</p>
<h2>Task lists</h2>
<p>Another really useful thing is to mark some of your code as TODO or
FIXME! I know we all like to think we write perfect code, but sometimes
you just have to settle and leave a note for yourself to come back
later. One of the plugins we included was the tasklist plugin that will
allow us to search all open buffers for things to fix. Just add a
mapping to open it in ~/.vimrc:</p>
<pre><code>map &#x3C;leader>td &#x3C;Plug>TaskList
</code></pre>
<p>Now you can hit &#x3C;leader>td to open your task list and hit 'q' to
close it. You can also hit enter on the task to jump to the buffer and
line that it is placed on.</p>
<h2>Revision History</h2>
<p>The final basic editing tweak I suggest everyone start utilizing is the
Gundo plugin. It'll allow you to view diff's of every save on a file
you've made and allow you to quickly revert back and forth:</p>
<p><img src="http://i.imgur.com/2NrPS.png" alt="image"></p>
<p>Just bind a key in your .vimrc to toggle the Gundo window:</p>
<pre><code>map &#x3C;leader>g :GundoToggle&#x3C;CR>
</code></pre>
<h1>Syntax Highlighting and Validation</h1>
<p>Simply enable syntax highlighting in your ~/.vimrc:</p>
<pre><code>syntax on                           " syntax highlighing
filetype on                          " try to detect filetypes
filetype plugin indent on    " enable loading indent file for filetype
</code></pre>
<p>Because we enabled pyflakes when we added it as a submodule in
~/.vim/bundle, it will notify you about unused imports and invalid
syntax. It will save you a lot of time saving and running just to find
out you missed a colon. I like to tell it not use the quickfix window:</p>
<pre><code>let g:pyflakes_use_quickfix = 0
</code></pre>
<p><img src="http://i.imgur.com/ZfjFe.png" alt="image"></p>
<h2>Pep8</h2>
<p>The final plugin that really helps validate your code is the pep8
plugin, it'll make sure your code is consistent across all projects.
Add a key mapping to your ~/.vimrc and then you'll be able to jump to
each of the pep8 violations in the quickfix window:</p>
<pre><code>let g:pep8_map='&#x3C;leader>8'
</code></pre>
<p><img src="http://i.imgur.com/VU9AB.png" alt="image"></p>
<h1>Tab Completion and Documentation</h1>
<p>Vim has many different code completion options. We are going to use the
SuperTab plugin to check the context of the code you are working on and
choose the best for the situation. We've already enabled the SuperTab
plugin in the bundle/ folder, so we just have to configure it to be
context sensitive and to enable omni code completion in your ~/.vimrc:</p>
<pre><code>au FileType python set omnifunc=pythoncomplete#Complete
let g:SuperTabDefaultCompletionType = "context"
</code></pre>
<p>Now we just enable the menu and pydoc preview to get the most useful
information out of the code completion:</p>
<pre><code>set completeopt=menuone,longest,preview
</code></pre>
<p><img src="http://i.imgur.com/g4lxP.png" alt="image"></p>
<p>We also enabled the pydoc plugin at the beginning with all the
submodules; that gives us the ability to hit &#x3C;leader>pw when our
cursor is on a module and have a new window open with the whole
documentation page for it.</p>
<h1>Code Navigation</h1>
<h2>Buffers</h2>
<p>The most important part about navigating code within vim, is to
completely understand how to use buffers. There is no reason to use
tabs. Open files with :e &#x3C;filename> to place in a buffer. We already
installed the minibufexpl plugin, so you will already visually see every
buffer opened. You can also get a list of them doing :buffers.</p>
<p>You can switch between the buffers using b&#x3C;number>, such as :b1 for
the first buffer. You can also use its name to match, so you can type :b
mod&#x3C;tab> to autocomplete opening the models.py buffer. You need to
make sure you are using the minibufexpl from my github since it has
patches that make it much better to work with.</p>
<p>To close a buffer you use :bd or :bw.</p>
<h2>Fuzzy Text File Search</h2>
<p>To make finding and opening files within your project even easier, we
are going to use the command-t plugin. It does have some parts that need
to be compiled, so its not already installed by adding it as a
submodule. Go to your ~/.vim/bundle/command-t folder and run 'rake
make'. Yes you need ruby installed. By default, command-t is bound to
&#x3C;leader>t. This will use fuzzy text matching to find any file in your
project.</p>
<p>It also supports searching only through opened buffers, instead of files
using &#x3C;leader>b.</p>
<p><img src="http://i.imgur.com/hUcSl.png" alt="image"></p>
<h2>File Browser</h2>
<p>NERD Tree is a project file browser. I must admit I used this heavily
back when I was migrating from Visual Studio and used to the Solution
Explorer, but I rarely use it anymore. Command-T is usually all you'll
need. It is useful when you are getting to know a new codebase for the
first time though. Lets bind a shortcut key for opening it:</p>
<pre><code>map &#x3C;leader>n :NERDTreeToggle&#x3C;CR>
</code></pre>
<p><img src="http://i.imgur.com/R4ZzQ.png" alt="image"></p>
<h2>Refactoring and Go to definition</h2>
<p>Ropevim is also a great tool that will allow you to navigate around your
code. It supports automatically inserting import statements, goto
definition, refactoring, and code completion. You'll really want to
read up on everything it does, but the two big things I use it for is to
jump to function or class definitions quickly and to rename things
(including all their references).</p>
<p>For instance, if you are using django and you place your cursor over the
class models.Model you reference and then called :RopeGotoDefintion, it
would jump you straight to the django library to that class definition.
We already have it installed in our bundles, so we bind it to a key to
use it:</p>
<pre><code>map &#x3C;leader>j :RopeGotoDefinition&#x3C;CR>
map &#x3C;leader>r :RopeRename&#x3C;CR>
</code></pre>
<h2>Searching</h2>
<p>The final tool that really speeds up navigating your code is the Ack
plugin. Ack is similar to grep, but much better in my opinion. You can
fuzzy text search for anything in your code (variable name, class,
method, etc) and it'll give you a list of files and line numbers where
they are defined so you can quickly cycle through them. Just bind the
searching to a key:</p>
<pre><code>nmap &#x3C;leader>a &#x3C;Esc>:Ack!
</code></pre>
<p>We use ! at the end of it so it doesn't open the first result
automatically.</p>
<h1>Integration with Git</h1>
<p>We installed 2 plugins, git.vim and fugitive, that give us all the
integration we need. Git.vim will provide us syntax highlighting for git
configuration files; fugitive provides a great interface for interacting
with git including getting diffs, status updates, committing, and moving
files.</p>
<p>Fugitive also allows you to view what branch you are working in directly
from vim. Add this to your statusline in ~/.vimrc:</p>
<pre><code>%{fugitive#statusline()}
</code></pre>
<p>The big commands you need to know:</p>
<ul>
<li><strong>Gblame</strong>: This allows you to view a line by line comparison of who
the last person to touch that line of code is.</li>
<li><strong>Gwrite</strong>: This will stage your file for commit, basically doing
git add &#x3C;filename></li>
<li><strong>Gread</strong>: This will basically run a git checkout &#x3C;filename></li>
<li><strong>Gcommit</strong>: This will just run git commit. Since its in a vim
buffer, you can use keyword completion (Ctrl-N), like
test_all&#x3C;Ctrl-N> to find the method name in your buffer and
complete it for the commit message. You can also use + and - on the
filenames in the message to stage/unstage them for the commit.</li>
</ul>
<p><img src="http://i.imgur.com/NuRRj.png" alt="image"></p>
<h1>Test Integration</h1>
<h2>django nose</h2>
<p>Test runner integration really depends on the testing library you are
using and what type of tests you are running but we included a great
generic plugin called MakeGreen that executes off of vim's makeprg
variable. So for instance, if you are using django with django-nose you
could define a shortcut key in your ~/.vimrc like this:</p>
<pre><code>map &#x3C;leader>dt :set makeprg=python\ manage.py\ test\|:call MakeGreen()&#x3C;CR>
</code></pre>
<p>This will just give you a green bar at the bottom of vim if your test
passed or a red bar with the message of the failed test if it doesn't.
Very simple.</p>
<h2>py.test</h2>
<p>I also included the py.test vim plugin for those who prefer it. This
plugin has a lot more functionality including executing individual tests
by class, file, or method. You can also cycle through the individual
assertion errors. I have the following bindings:</p>
<pre><code>" Execute the tests
nmap &#x3C;silent>&#x3C;Leader>tf &#x3C;Esc>:Pytest file&#x3C;CR>
nmap &#x3C;silent>&#x3C;Leader>tc &#x3C;Esc>:Pytest class&#x3C;CR>
nmap &#x3C;silent>&#x3C;Leader>tm &#x3C;Esc>:Pytest method&#x3C;CR>
" cycle through test errors
nmap &#x3C;silent>&#x3C;Leader>tn &#x3C;Esc>:Pytest next&#x3C;CR>
nmap &#x3C;silent>&#x3C;Leader>tp &#x3C;Esc>:Pytest previous&#x3C;CR>
nmap &#x3C;silent>&#x3C;Leader>te &#x3C;Esc>:Pytest error&#x3C;CR>
</code></pre>
<p><img src="http://i.imgur.com/RAE7v.png" alt="image"></p>
<h1>Virtualenv</h1>
<p>Vim doesn't realize that you are in a virtualenv so it wont give you
code completion for libraries only installed there. Add the following
script to your ~/.vimrc to fix it:</p>
<pre><code>" Add the virtualenv's site-packages to vim path
py &#x3C;&#x3C; EOF
import os.path
import sys
import vim
if 'VIRTUAL_ENV' in os.environ:
    project_base_dir = os.environ['VIRTUAL_ENV']
    sys.path.insert(0, project_base_dir)
    activate_this = os.path.join(project_base_dir, 'bin/activate_this.py')
    execfile(activate_this, dict(__file__=activate_this))
EOF
</code></pre>
<h1>Django</h1>
<p>The only true django tweak I make is before I open vim I'll export the
DJANGO_SETTINGS_MODULE environment so that I get code completion for
django modules as well:</p>
<pre><code>export DJANGO_SETTINGS_MODULE=project.settings
</code></pre>
<h1>Random Tips</h1>
<p>If you want to find a new color scheme just go to
<a href="http://code.google.com/p/vimcolorschemetest/">http://code.google.com/p/vimcolorschemetest/</a> to preview a large
selection.</p>
<p>John Anderson &#x3C;<a href="mailto:sontek@gmail.com">sontek@gmail.com</a>> 2011</p>
</div></article></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"turning_vim_into_a_modern_python_ide","contentHtml":"\u003cp\u003e::: {.contents}\n:::\u003c/p\u003e\n\u003cp\u003eTL;DR:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git clone https://github.com/sontek/dotfiles.git\n$ cd dotfiles\n$ ./install.sh vim\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eIntro\u003c/h1\u003e\n\u003cp\u003eBack in 2008, I wrote the article \u003ca href=\"http://sontek.net/python-with-a-modular-ide-vim\"\u003ePython with a modular IDE\n(Vim)\u003c/a\u003e. Years later, I\nhave people e-mailing me and commenting daily asking for more\ninformation, even though most of the information in it is outdated. Here\nis the modern way to work with Python and Vim to achieve the perfect\nenvironment.\u003c/p\u003e\n\u003cp\u003eBecause one of the most important parts about a development environment\nis the ability to easily reproduce across machines, we are going to\nstore our vim configuration in git:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ mkdir ~/.vim/\n$ mkdir ~/.vim/{autoload,bundle}\n$ cd ~/.vim/\n$ git init\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe purpose of the autoload directory is to automatically load the vim\nplugin \u003ca href=\"https://github.com/tpope/vim-pathogen\"\u003ePathogen\u003c/a\u003e, which we'll\nthen use to load all other plugins that are located in the bundle\ndirectory. So download pathogen and put it in your autoload folder.\u003c/p\u003e\n\u003cp\u003eYou'll need to add the following to your ~/.vimrc so that pathogen\nwill be loaded properly. Filetype detection must be off when you run the\ncommands so its best to execute them first:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efiletype off\ncall pathogen#runtime_append_all_bundles()\ncall pathogen#helptags()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow lets add all of the vim plugins we plan on using as submodules to\nour git repository:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egit submodule add http://github.com/tpope/vim-fugitive.git bundle/fugitive\ngit submodule add https://github.com/msanders/snipmate.vim.git bundle/snipmate\ngit submodule add https://github.com/tpope/vim-surround.git bundle/surround\ngit submodule add https://github.com/tpope/vim-git.git bundle/git\ngit submodule add https://github.com/ervandew/supertab.git bundle/supertab\ngit submodule add https://github.com/sontek/minibufexpl.vim.git bundle/minibufexpl\ngit submodule add https://github.com/wincent/Command-T.git bundle/command-t\ngit submodule add https://github.com/mitechie/pyflakes-pathogen.git\ngit submodule add https://github.com/mileszs/ack.vim.git bundle/ack\ngit submodule add https://github.com/sjl/gundo.vim.git bundle/gundo\ngit submodule add https://github.com/fs111/pydoc.vim.git bundle/pydoc\ngit submodule add https://github.com/vim-scripts/pep8.git bundle/pep8\ngit submodule add https://github.com/alfredodeza/pytest.vim.git bundle/py.test\ngit submodule add https://github.com/reinh/vim-makegreen bundle/makegreen\ngit submodule add https://github.com/vim-scripts/TaskList.vim.git bundle/tasklist\ngit submodule add https://github.com/vim-scripts/The-NERD-tree.git bundle/nerdtree\ngit submodule add https://github.com/sontek/rope-vim.git bundle/ropevim\ngit submodule init\ngit submodule update\ngit submodule foreach git submodule init\ngit submodule foreach git submodule update\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThats it! Now that we've got our vim configuration in git!\u003c/p\u003e\n\u003cp\u003eNow lets look at how to use each of these plugins to improve the power\nof vim:\u003c/p\u003e\n\u003ch1\u003eBasic Editing and Debugging\u003c/h1\u003e\n\u003ch2\u003eCode Folding\u003c/h2\u003e\n\u003cp\u003eLets first enable code folding. This makes it a lot easier to organize\nyour code and hide portions that you aren't interested in working on.\nThis is quite easy for Python, since whitespace is required.\u003c/p\u003e\n\u003cp\u003eIn your ~/.vimrc just add:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eset foldmethod=indent\nset foldlevel=99\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen you will be able to be inside a method and type 'za' to open and\nclose a fold.\u003c/p\u003e\n\u003ch2\u003eWindow Splits\u003c/h2\u003e\n\u003cp\u003eSometimes code folding isn't enough; you may need to start opening up\nmultiple windows and working on multiple files at once or different\nlocations within the same file. To do this in vim, you can use these\nshortcuts:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eVertical Split : Ctrl+w + v\nHorizontal Split: Ctrl+w + s\nClose current windows: Ctrl+w + q\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI also like to bind Ctrl+\u0026#x3C;movement\u003e keys to move around the windows,\ninstead of using Ctrl+w + \u0026#x3C;movement\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emap \u0026#x3C;c-j\u003e \u0026#x3C;c-w\u003ej\nmap \u0026#x3C;c-k\u003e \u0026#x3C;c-w\u003ek\nmap \u0026#x3C;c-l\u003e \u0026#x3C;c-w\u003el\nmap \u0026#x3C;c-h\u003e \u0026#x3C;c-w\u003eh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"http://i.imgur.com/krj0l.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003eSnippets\u003c/h2\u003e\n\u003cp\u003eThe next tweak that really speeds up development is using snipmate.\nWe've already included it in our bundle/ folder so its already enabled.\nTry opening up a python file and typing 'def\u0026#x3C;tab\u003e'. It should stub\nout a method definition for you and allow you to tab through and fill\nout the arguments, doc string, etc.\u003c/p\u003e\n\u003cp\u003eI also like to create my own snippets folder to put in some custom\nsnippets:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ mkdir ~/.vim/snippets\n$ vim ~/.vim/snippets/python.snippets\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePut this in the file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esnippet pdb\n    import pdb; pdb.set_trace()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow you can type pdb\u0026#x3C;tab\u003e and it'll insert your breakpoint!\u003c/p\u003e\n\u003ch2\u003eTask lists\u003c/h2\u003e\n\u003cp\u003eAnother really useful thing is to mark some of your code as TODO or\nFIXME! I know we all like to think we write perfect code, but sometimes\nyou just have to settle and leave a note for yourself to come back\nlater. One of the plugins we included was the tasklist plugin that will\nallow us to search all open buffers for things to fix. Just add a\nmapping to open it in ~/.vimrc:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emap \u0026#x3C;leader\u003etd \u0026#x3C;Plug\u003eTaskList\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow you can hit \u0026#x3C;leader\u003etd to open your task list and hit 'q' to\nclose it. You can also hit enter on the task to jump to the buffer and\nline that it is placed on.\u003c/p\u003e\n\u003ch2\u003eRevision History\u003c/h2\u003e\n\u003cp\u003eThe final basic editing tweak I suggest everyone start utilizing is the\nGundo plugin. It'll allow you to view diff's of every save on a file\nyou've made and allow you to quickly revert back and forth:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"http://i.imgur.com/2NrPS.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eJust bind a key in your .vimrc to toggle the Gundo window:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emap \u0026#x3C;leader\u003eg :GundoToggle\u0026#x3C;CR\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eSyntax Highlighting and Validation\u003c/h1\u003e\n\u003cp\u003eSimply enable syntax highlighting in your ~/.vimrc:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esyntax on                           \" syntax highlighing\nfiletype on                          \" try to detect filetypes\nfiletype plugin indent on    \" enable loading indent file for filetype\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBecause we enabled pyflakes when we added it as a submodule in\n~/.vim/bundle, it will notify you about unused imports and invalid\nsyntax. It will save you a lot of time saving and running just to find\nout you missed a colon. I like to tell it not use the quickfix window:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet g:pyflakes_use_quickfix = 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"http://i.imgur.com/ZfjFe.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003ePep8\u003c/h2\u003e\n\u003cp\u003eThe final plugin that really helps validate your code is the pep8\nplugin, it'll make sure your code is consistent across all projects.\nAdd a key mapping to your ~/.vimrc and then you'll be able to jump to\neach of the pep8 violations in the quickfix window:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet g:pep8_map='\u0026#x3C;leader\u003e8'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"http://i.imgur.com/VU9AB.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003eTab Completion and Documentation\u003c/h1\u003e\n\u003cp\u003eVim has many different code completion options. We are going to use the\nSuperTab plugin to check the context of the code you are working on and\nchoose the best for the situation. We've already enabled the SuperTab\nplugin in the bundle/ folder, so we just have to configure it to be\ncontext sensitive and to enable omni code completion in your ~/.vimrc:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eau FileType python set omnifunc=pythoncomplete#Complete\nlet g:SuperTabDefaultCompletionType = \"context\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we just enable the menu and pydoc preview to get the most useful\ninformation out of the code completion:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eset completeopt=menuone,longest,preview\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"http://i.imgur.com/g4lxP.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eWe also enabled the pydoc plugin at the beginning with all the\nsubmodules; that gives us the ability to hit \u0026#x3C;leader\u003epw when our\ncursor is on a module and have a new window open with the whole\ndocumentation page for it.\u003c/p\u003e\n\u003ch1\u003eCode Navigation\u003c/h1\u003e\n\u003ch2\u003eBuffers\u003c/h2\u003e\n\u003cp\u003eThe most important part about navigating code within vim, is to\ncompletely understand how to use buffers. There is no reason to use\ntabs. Open files with :e \u0026#x3C;filename\u003e to place in a buffer. We already\ninstalled the minibufexpl plugin, so you will already visually see every\nbuffer opened. You can also get a list of them doing :buffers.\u003c/p\u003e\n\u003cp\u003eYou can switch between the buffers using b\u0026#x3C;number\u003e, such as :b1 for\nthe first buffer. You can also use its name to match, so you can type :b\nmod\u0026#x3C;tab\u003e to autocomplete opening the models.py buffer. You need to\nmake sure you are using the minibufexpl from my github since it has\npatches that make it much better to work with.\u003c/p\u003e\n\u003cp\u003eTo close a buffer you use :bd or :bw.\u003c/p\u003e\n\u003ch2\u003eFuzzy Text File Search\u003c/h2\u003e\n\u003cp\u003eTo make finding and opening files within your project even easier, we\nare going to use the command-t plugin. It does have some parts that need\nto be compiled, so its not already installed by adding it as a\nsubmodule. Go to your ~/.vim/bundle/command-t folder and run 'rake\nmake'. Yes you need ruby installed. By default, command-t is bound to\n\u0026#x3C;leader\u003et. This will use fuzzy text matching to find any file in your\nproject.\u003c/p\u003e\n\u003cp\u003eIt also supports searching only through opened buffers, instead of files\nusing \u0026#x3C;leader\u003eb.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"http://i.imgur.com/hUcSl.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003eFile Browser\u003c/h2\u003e\n\u003cp\u003eNERD Tree is a project file browser. I must admit I used this heavily\nback when I was migrating from Visual Studio and used to the Solution\nExplorer, but I rarely use it anymore. Command-T is usually all you'll\nneed. It is useful when you are getting to know a new codebase for the\nfirst time though. Lets bind a shortcut key for opening it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emap \u0026#x3C;leader\u003en :NERDTreeToggle\u0026#x3C;CR\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"http://i.imgur.com/R4ZzQ.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003eRefactoring and Go to definition\u003c/h2\u003e\n\u003cp\u003eRopevim is also a great tool that will allow you to navigate around your\ncode. It supports automatically inserting import statements, goto\ndefinition, refactoring, and code completion. You'll really want to\nread up on everything it does, but the two big things I use it for is to\njump to function or class definitions quickly and to rename things\n(including all their references).\u003c/p\u003e\n\u003cp\u003eFor instance, if you are using django and you place your cursor over the\nclass models.Model you reference and then called :RopeGotoDefintion, it\nwould jump you straight to the django library to that class definition.\nWe already have it installed in our bundles, so we bind it to a key to\nuse it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emap \u0026#x3C;leader\u003ej :RopeGotoDefinition\u0026#x3C;CR\u003e\nmap \u0026#x3C;leader\u003er :RopeRename\u0026#x3C;CR\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eSearching\u003c/h2\u003e\n\u003cp\u003eThe final tool that really speeds up navigating your code is the Ack\nplugin. Ack is similar to grep, but much better in my opinion. You can\nfuzzy text search for anything in your code (variable name, class,\nmethod, etc) and it'll give you a list of files and line numbers where\nthey are defined so you can quickly cycle through them. Just bind the\nsearching to a key:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enmap \u0026#x3C;leader\u003ea \u0026#x3C;Esc\u003e:Ack!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe use ! at the end of it so it doesn't open the first result\nautomatically.\u003c/p\u003e\n\u003ch1\u003eIntegration with Git\u003c/h1\u003e\n\u003cp\u003eWe installed 2 plugins, git.vim and fugitive, that give us all the\nintegration we need. Git.vim will provide us syntax highlighting for git\nconfiguration files; fugitive provides a great interface for interacting\nwith git including getting diffs, status updates, committing, and moving\nfiles.\u003c/p\u003e\n\u003cp\u003eFugitive also allows you to view what branch you are working in directly\nfrom vim. Add this to your statusline in ~/.vimrc:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e%{fugitive#statusline()}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe big commands you need to know:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGblame\u003c/strong\u003e: This allows you to view a line by line comparison of who\nthe last person to touch that line of code is.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGwrite\u003c/strong\u003e: This will stage your file for commit, basically doing\ngit add \u0026#x3C;filename\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGread\u003c/strong\u003e: This will basically run a git checkout \u0026#x3C;filename\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGcommit\u003c/strong\u003e: This will just run git commit. Since its in a vim\nbuffer, you can use keyword completion (Ctrl-N), like\ntest_all\u0026#x3C;Ctrl-N\u003e to find the method name in your buffer and\ncomplete it for the commit message. You can also use + and - on the\nfilenames in the message to stage/unstage them for the commit.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"http://i.imgur.com/NuRRj.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003eTest Integration\u003c/h1\u003e\n\u003ch2\u003edjango nose\u003c/h2\u003e\n\u003cp\u003eTest runner integration really depends on the testing library you are\nusing and what type of tests you are running but we included a great\ngeneric plugin called MakeGreen that executes off of vim's makeprg\nvariable. So for instance, if you are using django with django-nose you\ncould define a shortcut key in your ~/.vimrc like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emap \u0026#x3C;leader\u003edt :set makeprg=python\\ manage.py\\ test\\|:call MakeGreen()\u0026#x3C;CR\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will just give you a green bar at the bottom of vim if your test\npassed or a red bar with the message of the failed test if it doesn't.\nVery simple.\u003c/p\u003e\n\u003ch2\u003epy.test\u003c/h2\u003e\n\u003cp\u003eI also included the py.test vim plugin for those who prefer it. This\nplugin has a lot more functionality including executing individual tests\nby class, file, or method. You can also cycle through the individual\nassertion errors. I have the following bindings:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\" Execute the tests\nnmap \u0026#x3C;silent\u003e\u0026#x3C;Leader\u003etf \u0026#x3C;Esc\u003e:Pytest file\u0026#x3C;CR\u003e\nnmap \u0026#x3C;silent\u003e\u0026#x3C;Leader\u003etc \u0026#x3C;Esc\u003e:Pytest class\u0026#x3C;CR\u003e\nnmap \u0026#x3C;silent\u003e\u0026#x3C;Leader\u003etm \u0026#x3C;Esc\u003e:Pytest method\u0026#x3C;CR\u003e\n\" cycle through test errors\nnmap \u0026#x3C;silent\u003e\u0026#x3C;Leader\u003etn \u0026#x3C;Esc\u003e:Pytest next\u0026#x3C;CR\u003e\nnmap \u0026#x3C;silent\u003e\u0026#x3C;Leader\u003etp \u0026#x3C;Esc\u003e:Pytest previous\u0026#x3C;CR\u003e\nnmap \u0026#x3C;silent\u003e\u0026#x3C;Leader\u003ete \u0026#x3C;Esc\u003e:Pytest error\u0026#x3C;CR\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"http://i.imgur.com/RAE7v.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003eVirtualenv\u003c/h1\u003e\n\u003cp\u003eVim doesn't realize that you are in a virtualenv so it wont give you\ncode completion for libraries only installed there. Add the following\nscript to your ~/.vimrc to fix it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\" Add the virtualenv's site-packages to vim path\npy \u0026#x3C;\u0026#x3C; EOF\nimport os.path\nimport sys\nimport vim\nif 'VIRTUAL_ENV' in os.environ:\n    project_base_dir = os.environ['VIRTUAL_ENV']\n    sys.path.insert(0, project_base_dir)\n    activate_this = os.path.join(project_base_dir, 'bin/activate_this.py')\n    execfile(activate_this, dict(__file__=activate_this))\nEOF\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eDjango\u003c/h1\u003e\n\u003cp\u003eThe only true django tweak I make is before I open vim I'll export the\nDJANGO_SETTINGS_MODULE environment so that I get code completion for\ndjango modules as well:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport DJANGO_SETTINGS_MODULE=project.settings\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eRandom Tips\u003c/h1\u003e\n\u003cp\u003eIf you want to find a new color scheme just go to\n\u003ca href=\"http://code.google.com/p/vimcolorschemetest/\"\u003ehttp://code.google.com/p/vimcolorschemetest/\u003c/a\u003e to preview a large\nselection.\u003c/p\u003e\n\u003cp\u003eJohn Anderson \u0026#x3C;\u003ca href=\"mailto:sontek@gmail.com\"\u003esontek@gmail.com\u003c/a\u003e\u003e 2011\u003c/p\u003e\n","category":"python\n","date":"2011-05-06T20:00:00-04:00","tags":"vim, python\n","title":"Turning Vim into a modern Python IDE"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"turning_vim_into_a_modern_python_ide"},"buildId":"5XCxPLpqOzpyhJfzxeJqg","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>