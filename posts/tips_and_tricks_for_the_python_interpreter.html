<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Tips and Tricks for the Python Interpreter</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/6060a664e90c5fb4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6060a664e90c5fb4.css" data-n-g=""/><link rel="preload" href="/_next/static/css/421ede9ab5a915a5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/421ede9ab5a915a5.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-529e237f188dc66d.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4777b1b835b905e6.js" defer=""></script><script src="/_next/static/chunks/247-d3d7ac0b996191c6.js" defer=""></script><script src="/_next/static/chunks/771-27d3774815323288.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-82dab2af2ec90eff.js" defer=""></script><script src="/_next/static/Jb1dxCSXnoe0EUqsCHzQQ/_buildManifest.js" defer=""></script><script src="/_next/static/Jb1dxCSXnoe0EUqsCHzQQ/_ssgManifest.js" defer=""></script><script src="/_next/static/Jb1dxCSXnoe0EUqsCHzQQ/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div><div class="grid"><div class="col"><header id="banner" class="body"><h1><a href="/">sontek.net</a></h1></header></div><div class="col menu"><nav><ul><li><a href="/">Home</a></li><li><a href="/blog">Blog</a></li><li><a href="/resume">Resume</a></li><li><a href="/about">About</a></li></ul></nav></div></div><div class="container"><article><h1 class="util_headingXl__38r1h">Tips and Tricks for the Python Interpreter</h1><div class="util_lightText__1ajZN"><time dateTime="2010-12-27T20:00:00-04:00">December 27, 2010</time></div><div><p>I have seen a lot of people switch over to using ipython, bpython, etc
to get auto-complete support without realizing that the standard
interpreter does have this functionality.</p>
<p>To enable auto-complete support in the python interpreter you need to
create a python startup file that enables readline support. A python
startup file is just a bunch of python code that gets executed at
startup of the interpreter. To do this you just setup PYTHONSTARTUP in
your ~/.bashrc and then create a ~/.pythonrc.py file:</p>
<pre><code><span>#.bashrc</span>
PYTHONSTARTUP=~/.pythonrc.py
export PYTHONSTARTUP

<span>#.pythonrc.py</span>
<span>try</span>:
    <span>import</span> readline
<span>except</span> ImportError:
    <span>print</span>(<span>"Module readline not available."</span>)
<span>else</span>:
    <span>import</span> rlcompleter
    readline.parse_and_bind(<span>"tab: complete"</span>)</code></pre>
<p>Now when you are in python you have tab completion on importing, calling
methods on a module, etc.</p>
<pre><code><span>>>> </span><span>import</span> o
<span>object</span>(  <span>oct</span>(     <span>open</span>(    <span>or</span>       <span>ord</span>(     os</code></pre>
<p>I always end up using the pretty print module for viewing long lists and
strings in the interpreter so I prefer to just use it by default:</p>
<pre><code><span># Enable Pretty Printing for stdout</span>
<span>import</span> pprint
<span>def</span> <span>my_displayhook</span>(<span>value</span>):
    <span>if</span> value <span>is</span> <span>not</span> <span>None</span>:
        <span>try</span>:
            <span>import</span> __builtin__
            __builtin__._ = value
        <span>except</span> ImportError:
            __builtins__._ = value

        pprint.pprint(value)

sys.displayhook = my_displayhook</code></pre>
<p>It is also very useful to be able to load up your favorite editor to
edit lines of code from the interpreter, you can do this by adding the
following into your ~/.pythonrc.py:</p>
<pre><code><span>import</span> os
<span>import</span> sys
<span>from</span> code <span>import</span> InteractiveConsole
<span>from</span> tempfile <span>import</span> mkstemp

EDITOR = os.environ.get(<span>'EDITOR'</span>, <span>'vi'</span>)
EDIT_CMD = <span>'\e'</span>

<span>class</span> <span>EditableBufferInteractiveConsole</span>(<span>InteractiveConsole</span>):
    <span>def</span> <span>__init__</span>(<span>self, *args, **kwargs</span>):
        self.last_buffer = [] <span># This holds the last executed statement</span>
        InteractiveConsole.__init__(self, *args, **kwargs)

    <span>def</span> <span>runsource</span>(<span>self, source, *args</span>):
        self.last_buffer = [ source.encode(<span>'latin-1'</span>) ]
        <span>return</span> InteractiveConsole.runsource(self, source, *args)

    <span>def</span> <span>raw_input</span>(<span>self, *args</span>):
        line = InteractiveConsole.raw_input(self, *args)
        <span>if</span> line == EDIT_CMD:
            fd, tmpfl = mkstemp(<span>'.py'</span>)
            os.write(fd, <span>b'\n'</span>.join(self.last_buffer))
            os.close(fd)
            os.system(<span>'%s %s'</span> % (EDITOR, tmpfl))
            line = <span>open</span>(tmpfl).read()
            os.unlink(tmpfl)
            tmpfl = <span>''</span>
            lines = line.split( <span>'\n'</span> )
            <span>for</span> i <span>in</span> <span>range</span>(<span>len</span>(lines) - <span>1</span>): self.push( lines[i] )
            line = lines[-<span>1</span>]
        <span>return</span> line

c = EditableBufferInteractiveConsole(<span>locals</span>=<span>locals</span>())
c.interact(banner=<span>''</span>)

<span># Exit the Python shell on exiting the InteractiveConsole</span>
sys.exit()</code></pre>
<p>For Django developers when you load up the ./manage.py shell it is nice
to have access to all your models and settings for testing:</p>
<pre><code><span># If we're working with a Django project, set up the environment</span>
<span>if</span> <span>'DJANGO_SETTINGS_MODULE'</span> <span>in</span> os.environ:
    <span>from</span> django.db.models.loading <span>import</span> get_models
    <span>from</span> django.test.client <span>import</span> Client
    <span>from</span> django.test.utils <span>import</span> setup_test_environment, teardown_test_environment
    <span>from</span> django.conf <span>import</span> settings <span>as</span> S

    <span>class</span> <span>DjangoModels</span>(<span>object</span>):
        <span>"""Loop through all the models in INSTALLED_APPS and import them."""</span>
        <span>def</span> <span>__init__</span>(<span>self</span>):
            <span>for</span> m <span>in</span> get_models():
                <span>setattr</span>(self, m.__name__, m)

    A = DjangoModels()
    C = Client()</code></pre>
<p>After these tweaks the python interpreter is a lot more powerful and you
really lose the need for the more interactive shells like ipython and
bpython. All of these settings work in both python2 and python3.</p>
<p>If you want to see my complete ~/.pythonrc.py you can get it on
<a href="https://github.com/sontek/dotfiles/blob/master/_pythonrc.py">github</a></p>
</div></article></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"tips_and_tricks_for_the_python_interpreter","contentHtml":"\u003cp\u003eI have seen a lot of people switch over to using ipython, bpython, etc\nto get auto-complete support without realizing that the standard\ninterpreter does have this functionality.\u003c/p\u003e\n\u003cp\u003eTo enable auto-complete support in the python interpreter you need to\ncreate a python startup file that enables readline support. A python\nstartup file is just a bunch of python code that gets executed at\nstartup of the interpreter. To do this you just setup PYTHONSTARTUP in\nyour ~/.bashrc and then create a ~/.pythonrc.py file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e#.bashrc\u003c/span\u003e\nPYTHONSTARTUP=~/.pythonrc.py\nexport PYTHONSTARTUP\n\n\u003cspan\u003e#.pythonrc.py\u003c/span\u003e\n\u003cspan\u003etry\u003c/span\u003e:\n    \u003cspan\u003eimport\u003c/span\u003e readline\n\u003cspan\u003eexcept\u003c/span\u003e ImportError:\n    \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003e\"Module readline not available.\"\u003c/span\u003e)\n\u003cspan\u003eelse\u003c/span\u003e:\n    \u003cspan\u003eimport\u003c/span\u003e rlcompleter\n    readline.parse_and_bind(\u003cspan\u003e\"tab: complete\"\u003c/span\u003e)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow when you are in python you have tab completion on importing, calling\nmethods on a module, etc.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003e\u003e\u003e \u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e o\n\u003cspan\u003eobject\u003c/span\u003e(  \u003cspan\u003eoct\u003c/span\u003e(     \u003cspan\u003eopen\u003c/span\u003e(    \u003cspan\u003eor\u003c/span\u003e       \u003cspan\u003eord\u003c/span\u003e(     os\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI always end up using the pretty print module for viewing long lists and\nstrings in the interpreter so I prefer to just use it by default:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e# Enable Pretty Printing for stdout\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e pprint\n\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003emy_displayhook\u003c/span\u003e(\u003cspan\u003evalue\u003c/span\u003e):\n    \u003cspan\u003eif\u003c/span\u003e value \u003cspan\u003eis\u003c/span\u003e \u003cspan\u003enot\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e:\n        \u003cspan\u003etry\u003c/span\u003e:\n            \u003cspan\u003eimport\u003c/span\u003e __builtin__\n            __builtin__._ = value\n        \u003cspan\u003eexcept\u003c/span\u003e ImportError:\n            __builtins__._ = value\n\n        pprint.pprint(value)\n\nsys.displayhook = my_displayhook\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is also very useful to be able to load up your favorite editor to\nedit lines of code from the interpreter, you can do this by adding the\nfollowing into your ~/.pythonrc.py:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e os\n\u003cspan\u003eimport\u003c/span\u003e sys\n\u003cspan\u003efrom\u003c/span\u003e code \u003cspan\u003eimport\u003c/span\u003e InteractiveConsole\n\u003cspan\u003efrom\u003c/span\u003e tempfile \u003cspan\u003eimport\u003c/span\u003e mkstemp\n\nEDITOR = os.environ.get(\u003cspan\u003e'EDITOR'\u003c/span\u003e, \u003cspan\u003e'vi'\u003c/span\u003e)\nEDIT_CMD = \u003cspan\u003e'\\e'\u003c/span\u003e\n\n\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eEditableBufferInteractiveConsole\u003c/span\u003e(\u003cspan\u003eInteractiveConsole\u003c/span\u003e):\n    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__init__\u003c/span\u003e(\u003cspan\u003eself, *args, **kwargs\u003c/span\u003e):\n        self.last_buffer = [] \u003cspan\u003e# This holds the last executed statement\u003c/span\u003e\n        InteractiveConsole.__init__(self, *args, **kwargs)\n\n    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003erunsource\u003c/span\u003e(\u003cspan\u003eself, source, *args\u003c/span\u003e):\n        self.last_buffer = [ source.encode(\u003cspan\u003e'latin-1'\u003c/span\u003e) ]\n        \u003cspan\u003ereturn\u003c/span\u003e InteractiveConsole.runsource(self, source, *args)\n\n    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eraw_input\u003c/span\u003e(\u003cspan\u003eself, *args\u003c/span\u003e):\n        line = InteractiveConsole.raw_input(self, *args)\n        \u003cspan\u003eif\u003c/span\u003e line == EDIT_CMD:\n            fd, tmpfl = mkstemp(\u003cspan\u003e'.py'\u003c/span\u003e)\n            os.write(fd, \u003cspan\u003eb'\\n'\u003c/span\u003e.join(self.last_buffer))\n            os.close(fd)\n            os.system(\u003cspan\u003e'%s %s'\u003c/span\u003e % (EDITOR, tmpfl))\n            line = \u003cspan\u003eopen\u003c/span\u003e(tmpfl).read()\n            os.unlink(tmpfl)\n            tmpfl = \u003cspan\u003e''\u003c/span\u003e\n            lines = line.split( \u003cspan\u003e'\\n'\u003c/span\u003e )\n            \u003cspan\u003efor\u003c/span\u003e i \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003erange\u003c/span\u003e(\u003cspan\u003elen\u003c/span\u003e(lines) - \u003cspan\u003e1\u003c/span\u003e): self.push( lines[i] )\n            line = lines[-\u003cspan\u003e1\u003c/span\u003e]\n        \u003cspan\u003ereturn\u003c/span\u003e line\n\nc = EditableBufferInteractiveConsole(\u003cspan\u003elocals\u003c/span\u003e=\u003cspan\u003elocals\u003c/span\u003e())\nc.interact(banner=\u003cspan\u003e''\u003c/span\u003e)\n\n\u003cspan\u003e# Exit the Python shell on exiting the InteractiveConsole\u003c/span\u003e\nsys.exit()\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor Django developers when you load up the ./manage.py shell it is nice\nto have access to all your models and settings for testing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e# If we're working with a Django project, set up the environment\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e'DJANGO_SETTINGS_MODULE'\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e os.environ:\n    \u003cspan\u003efrom\u003c/span\u003e django.db.models.loading \u003cspan\u003eimport\u003c/span\u003e get_models\n    \u003cspan\u003efrom\u003c/span\u003e django.test.client \u003cspan\u003eimport\u003c/span\u003e Client\n    \u003cspan\u003efrom\u003c/span\u003e django.test.utils \u003cspan\u003eimport\u003c/span\u003e setup_test_environment, teardown_test_environment\n    \u003cspan\u003efrom\u003c/span\u003e django.conf \u003cspan\u003eimport\u003c/span\u003e settings \u003cspan\u003eas\u003c/span\u003e S\n\n    \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eDjangoModels\u003c/span\u003e(\u003cspan\u003eobject\u003c/span\u003e):\n        \u003cspan\u003e\"\"\"Loop through all the models in INSTALLED_APPS and import them.\"\"\"\u003c/span\u003e\n        \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__init__\u003c/span\u003e(\u003cspan\u003eself\u003c/span\u003e):\n            \u003cspan\u003efor\u003c/span\u003e m \u003cspan\u003ein\u003c/span\u003e get_models():\n                \u003cspan\u003esetattr\u003c/span\u003e(self, m.__name__, m)\n\n    A = DjangoModels()\n    C = Client()\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAfter these tweaks the python interpreter is a lot more powerful and you\nreally lose the need for the more interactive shells like ipython and\nbpython. All of these settings work in both python2 and python3.\u003c/p\u003e\n\u003cp\u003eIf you want to see my complete ~/.pythonrc.py you can get it on\n\u003ca href=\"https://github.com/sontek/dotfiles/blob/master/_pythonrc.py\"\u003egithub\u003c/a\u003e\u003c/p\u003e\n","category":"python\n","date":"2010-12-27T20:00:00-04:00","tags":"python\n","title":"Tips and Tricks for the Python Interpreter"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"tips_and_tricks_for_the_python_interpreter"},"buildId":"Jb1dxCSXnoe0EUqsCHzQQ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>