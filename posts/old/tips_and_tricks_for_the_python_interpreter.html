<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Tips and Tricks for the Python Interpreter</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/6060a664e90c5fb4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6060a664e90c5fb4.css" data-n-g=""/><link rel="preload" href="/_next/static/css/ce4e7e8185919ac0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ce4e7e8185919ac0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-d7b038a63b619762.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-7d0be5702b1cad24.js" defer=""></script><script src="/_next/static/chunks/pages/_app-db340e45743e5304.js" defer=""></script><script src="/_next/static/chunks/395-021075f5bc54064e.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...id%5D-b76736eff1b57221.js" defer=""></script><script src="/_next/static/3HfRYgeFAGbddGbKqavFP/_buildManifest.js" defer=""></script><script src="/_next/static/3HfRYgeFAGbddGbKqavFP/_ssgManifest.js" defer=""></script><script src="/_next/static/3HfRYgeFAGbddGbKqavFP/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><div class="grid"><div class="col"><header id="banner" class="body"><h1><a href="/">sontek.net</a></h1></header></div><div class="col menu"><nav><ul><li><a href="/">Home</a></li><li><a href="/blog">Blog</a></li><li><a href="/resume">Resume</a></li><li><a href="/about">About</a></li></ul></nav></div></div><div class="container"><article class="blog_article__NoEy4"><h1 class="util_headingXl__knZ_h">Tips and Tricks for the Python Interpreter</h1><div class="util_lightText__xcqUE"><time dateTime="2010-12-27T20:00:00-04:00">December 27, 2010</time></div><div><p>I have seen a lot of people switch over to using ipython, bpython, etc
to get auto-complete support without realizing that the standard
interpreter does have this functionality.</p>
<p>To enable auto-complete support in the python interpreter you need to
create a python startup file that enables readline support. A python
startup file is just a bunch of python code that gets executed at
startup of the interpreter. To do this you just setup PYTHONSTARTUP in
your ~/.bashrc and then create a ~/.pythonrc.py file:</p>
<pre><code class="hljs language-python"><span class="hljs-comment">#.bashrc</span>
PYTHONSTARTUP=~/.pythonrc.py
export PYTHONSTARTUP

<span class="hljs-comment">#.pythonrc.py</span>
<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">import</span> readline
<span class="hljs-keyword">except</span> ImportError:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Module readline not available."</span>)
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">import</span> rlcompleter
    readline.parse_and_bind(<span class="hljs-string">"tab: complete"</span>)
</code></pre>
<p>Now when you are in python you have tab completion on importing, calling
methods on a module, etc.</p>
<pre><code class="hljs language-python"><span class="hljs-meta">>>> </span><span class="hljs-keyword">import</span> o
<span class="hljs-built_in">object</span>(  <span class="hljs-built_in">oct</span>(     <span class="hljs-built_in">open</span>(    <span class="hljs-keyword">or</span>       <span class="hljs-built_in">ord</span>(     os
</code></pre>
<p>I always end up using the pretty print module for viewing long lists and
strings in the interpreter so I prefer to just use it by default:</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># Enable Pretty Printing for stdout</span>
<span class="hljs-keyword">import</span> pprint
<span class="hljs-keyword">def</span> <span class="hljs-title hljs-function">my_displayhook</span>(<span class="hljs-params">value</span>):
    <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">import</span> __builtin__
            __builtin__._ = value
        <span class="hljs-keyword">except</span> ImportError:
            __builtins__._ = value

        pprint.pprint(value)

sys.displayhook = my_displayhook
</code></pre>
<p>It is also very useful to be able to load up your favorite editor to
edit lines of code from the interpreter, you can do this by adding the
following into your ~/.pythonrc.py:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> code <span class="hljs-keyword">import</span> InteractiveConsole
<span class="hljs-keyword">from</span> tempfile <span class="hljs-keyword">import</span> mkstemp

EDITOR = os.environ.get(<span class="hljs-string">'EDITOR'</span>, <span class="hljs-string">'vi'</span>)
EDIT_CMD = <span class="hljs-string">'\e'</span>

<span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">EditableBufferInteractiveConsole</span>(<span class="hljs-title hljs-class hljs-inherited">InteractiveConsole</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title hljs-function">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        self.last_buffer = [] <span class="hljs-comment"># This holds the last executed statement</span>
        InteractiveConsole.__init__(self, *args, **kwargs)

    <span class="hljs-keyword">def</span> <span class="hljs-title hljs-function">runsource</span>(<span class="hljs-params">self, source, *args</span>):
        self.last_buffer = [ source.encode(<span class="hljs-string">'latin-1'</span>) ]
        <span class="hljs-keyword">return</span> InteractiveConsole.runsource(self, source, *args)

    <span class="hljs-keyword">def</span> <span class="hljs-title hljs-function">raw_input</span>(<span class="hljs-params">self, *args</span>):
        line = InteractiveConsole.raw_input(self, *args)
        <span class="hljs-keyword">if</span> line == EDIT_CMD:
            fd, tmpfl = mkstemp(<span class="hljs-string">'.py'</span>)
            os.write(fd, <span class="hljs-string">b'\n'</span>.join(self.last_buffer))
            os.close(fd)
            os.system(<span class="hljs-string">'%s %s'</span> % (EDITOR, tmpfl))
            line = <span class="hljs-built_in">open</span>(tmpfl).read()
            os.unlink(tmpfl)
            tmpfl = <span class="hljs-string">''</span>
            lines = line.split( <span class="hljs-string">'\n'</span> )
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lines) - <span class="hljs-number">1</span>): self.push( lines[i] )
            line = lines[-<span class="hljs-number">1</span>]
        <span class="hljs-keyword">return</span> line

c = EditableBufferInteractiveConsole(<span class="hljs-built_in">locals</span>=<span class="hljs-built_in">locals</span>())
c.interact(banner=<span class="hljs-string">''</span>)

<span class="hljs-comment"># Exit the Python shell on exiting the InteractiveConsole</span>
sys.exit()
</code></pre>
<p>For Django developers when you load up the ./manage.py shell it is nice
to have access to all your models and settings for testing:</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># If we're working with a Django project, set up the environment</span>
<span class="hljs-keyword">if</span> <span class="hljs-string">'DJANGO_SETTINGS_MODULE'</span> <span class="hljs-keyword">in</span> os.environ:
    <span class="hljs-keyword">from</span> django.db.models.loading <span class="hljs-keyword">import</span> get_models
    <span class="hljs-keyword">from</span> django.test.client <span class="hljs-keyword">import</span> Client
    <span class="hljs-keyword">from</span> django.test.utils <span class="hljs-keyword">import</span> setup_test_environment, teardown_test_environment
    <span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings <span class="hljs-keyword">as</span> S

    <span class="hljs-keyword">class</span> <span class="hljs-title hljs-class">DjangoModels</span>(<span class="hljs-title hljs-class hljs-inherited">object</span>):
        <span class="hljs-string">"""Loop through all the models in INSTALLED_APPS and import them."""</span>
        <span class="hljs-keyword">def</span> <span class="hljs-title hljs-function">__init__</span>(<span class="hljs-params">self</span>):
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> get_models():
                <span class="hljs-built_in">setattr</span>(self, m.__name__, m)

    A = DjangoModels()
    C = Client()
</code></pre>
<p>After these tweaks the python interpreter is a lot more powerful and you
really lose the need for the more interactive shells like ipython and
bpython. All of these settings work in both python2 and python3.</p>
<p>If you want to see my complete ~/.pythonrc.py you can get it on
<a href="https://github.com/sontek/dotfiles/blob/master/_pythonrc.py">github</a></p></div></article></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":["old","tips_and_tricks_for_the_python_interpreter"],"path":"old/tips_and_tricks_for_the_python_interpreter","contentHtml":"\u003cp\u003eI have seen a lot of people switch over to using ipython, bpython, etc\nto get auto-complete support without realizing that the standard\ninterpreter does have this functionality.\u003c/p\u003e\n\u003cp\u003eTo enable auto-complete support in the python interpreter you need to\ncreate a python startup file that enables readline support. A python\nstartup file is just a bunch of python code that gets executed at\nstartup of the interpreter. To do this you just setup PYTHONSTARTUP in\nyour ~/.bashrc and then create a ~/.pythonrc.py file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e#.bashrc\u003c/span\u003e\nPYTHONSTARTUP=~/.pythonrc.py\nexport PYTHONSTARTUP\n\n\u003cspan class=\"hljs-comment\"\u003e#.pythonrc.py\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e readline\n\u003cspan class=\"hljs-keyword\"\u003eexcept\u003c/span\u003e ImportError:\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Module readline not available.\"\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e rlcompleter\n    readline.parse_and_bind(\u003cspan class=\"hljs-string\"\u003e\"tab: complete\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow when you are in python you have tab completion on importing, calling\nmethods on a module, etc.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-meta\"\u003e\u003e\u003e\u003e \u003c/span\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e o\n\u003cspan class=\"hljs-built_in\"\u003eobject\u003c/span\u003e(  \u003cspan class=\"hljs-built_in\"\u003eoct\u003c/span\u003e(     \u003cspan class=\"hljs-built_in\"\u003eopen\u003c/span\u003e(    \u003cspan class=\"hljs-keyword\"\u003eor\u003c/span\u003e       \u003cspan class=\"hljs-built_in\"\u003eord\u003c/span\u003e(     os\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI always end up using the pretty print module for viewing long lists and\nstrings in the interpreter so I prefer to just use it by default:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# Enable Pretty Printing for stdout\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pprint\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003emy_displayhook\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e value \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enot\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e __builtin__\n            __builtin__._ = value\n        \u003cspan class=\"hljs-keyword\"\u003eexcept\u003c/span\u003e ImportError:\n            __builtins__._ = value\n\n        pprint.pprint(value)\n\nsys.displayhook = my_displayhook\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is also very useful to be able to load up your favorite editor to\nedit lines of code from the interpreter, you can do this by adding the\nfollowing into your ~/.pythonrc.py:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e sys\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e code \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e InteractiveConsole\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e tempfile \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e mkstemp\n\nEDITOR = os.environ.get(\u003cspan class=\"hljs-string\"\u003e'EDITOR'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'vi'\u003c/span\u003e)\nEDIT_CMD = \u003cspan class=\"hljs-string\"\u003e'\\e'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title hljs-class\"\u003eEditableBufferInteractiveConsole\u003c/span\u003e(\u003cspan class=\"hljs-title hljs-class hljs-inherited\"\u003eInteractiveConsole\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, *args, **kwargs\u003c/span\u003e):\n        self.last_buffer = [] \u003cspan class=\"hljs-comment\"\u003e# This holds the last executed statement\u003c/span\u003e\n        InteractiveConsole.__init__(self, *args, **kwargs)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003erunsource\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, source, *args\u003c/span\u003e):\n        self.last_buffer = [ source.encode(\u003cspan class=\"hljs-string\"\u003e'latin-1'\u003c/span\u003e) ]\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e InteractiveConsole.runsource(self, source, *args)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003eraw_input\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, *args\u003c/span\u003e):\n        line = InteractiveConsole.raw_input(self, *args)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e line == EDIT_CMD:\n            fd, tmpfl = mkstemp(\u003cspan class=\"hljs-string\"\u003e'.py'\u003c/span\u003e)\n            os.write(fd, \u003cspan class=\"hljs-string\"\u003eb'\\n'\u003c/span\u003e.join(self.last_buffer))\n            os.close(fd)\n            os.system(\u003cspan class=\"hljs-string\"\u003e'%s %s'\u003c/span\u003e % (EDITOR, tmpfl))\n            line = \u003cspan class=\"hljs-built_in\"\u003eopen\u003c/span\u003e(tmpfl).read()\n            os.unlink(tmpfl)\n            tmpfl = \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e\n            lines = line.split( \u003cspan class=\"hljs-string\"\u003e'\\n'\u003c/span\u003e )\n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(lines) - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e): self.push( lines[i] )\n            line = lines[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e line\n\nc = EditableBufferInteractiveConsole(\u003cspan class=\"hljs-built_in\"\u003elocals\u003c/span\u003e=\u003cspan class=\"hljs-built_in\"\u003elocals\u003c/span\u003e())\nc.interact(banner=\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e# Exit the Python shell on exiting the InteractiveConsole\u003c/span\u003e\nsys.exit()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor Django developers when you load up the ./manage.py shell it is nice\nto have access to all your models and settings for testing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# If we're working with a Django project, set up the environment\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'DJANGO_SETTINGS_MODULE'\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e os.environ:\n    \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e django.db.models.loading \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e get_models\n    \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e django.test.client \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Client\n    \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e django.test.utils \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e setup_test_environment, teardown_test_environment\n    \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e django.conf \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e settings \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e S\n\n    \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title hljs-class\"\u003eDjangoModels\u003c/span\u003e(\u003cspan class=\"hljs-title hljs-class hljs-inherited\"\u003eobject\u003c/span\u003e):\n        \u003cspan class=\"hljs-string\"\u003e\"\"\"Loop through all the models in INSTALLED_APPS and import them.\"\"\"\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e m \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e get_models():\n                \u003cspan class=\"hljs-built_in\"\u003esetattr\u003c/span\u003e(self, m.__name__, m)\n\n    A = DjangoModels()\n    C = Client()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAfter these tweaks the python interpreter is a lot more powerful and you\nreally lose the need for the more interactive shells like ipython and\nbpython. All of these settings work in both python2 and python3.\u003c/p\u003e\n\u003cp\u003eIf you want to see my complete ~/.pythonrc.py you can get it on\n\u003ca href=\"https://github.com/sontek/dotfiles/blob/master/_pythonrc.py\"\u003egithub\u003c/a\u003e\u003c/p\u003e","category":"python\n","date":"2010-12-27T20:00:00-04:00","tags":"python\n","title":"Tips and Tricks for the Python Interpreter"}},"__N_SSG":true},"page":"/posts/[...id]","query":{"id":["old","tips_and_tricks_for_the_python_interpreter"]},"buildId":"3HfRYgeFAGbddGbKqavFP","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>